# 开始着手

## 全军出击

好吧，我们出发吧！如果你是一个讨厌的家伙，居然不看上一章介绍就跳过了，你可能也会看看介绍里边最后的一部分，因为它提到你需要学习本教程需要准备的一些东西，还有我们是如何加载函数的。我们要做的第一件事情就是执行ghc的交互模式，并且调用函数去获取对baskell一些感性认识。现在就可以打开终端，输入ghci命令。你将会收到这样的问候。

```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help  
Loading package base ... linking ... done.  
Prelude>  
```

恭喜你，你已经进入GHCI了！这里提示 `Prelude>`，但当你加载东西到回话中的话，显示的信息会变得更多些。这里，我们将使用 `ghci>` 如果你想拥有相同的提示，只需要输入 `:set prompt "ghci>"`。

这里有一些简单计算，我们来看下

```haskell
ghci> 2 + 15  
17  
ghci> 49 * 100  
4900  
ghci> 1892 - 1472  
420  
ghci> 5 / 2  
2.5  
ghci>  
```

这是不言自明的。我们还可以在一行上使用多个操作符，并且遵守所有通常的优先规则。我们可以使用括号来明确优先级或更改优先级。

```haskell
ghci> (50 * 100) - 4999  
1  
ghci> 50 * 100 - 4999  
1  
ghci> 50 * (100 - 4999)  
-244950   
```

酷不?当然，可能不是很酷，当我觉得已经很酷了。这里要注意的一点是负数。如果我们想用负数，最好是用括号括起来。如果输入 `5 * -3` ,GHCI会对你咆哮，如果是 `5 *(-3)` 则没有什么问题。

布尔代数也很简单。你可能已经知道，&&代表的是并，||代表或，not代表否定。

```haskell
ghci> True && False  
False  
ghci> True && True  
True  
ghci> False || True  
True   
ghci> not False  
True  
ghci> not (True && True)  
False   
```

对平等的测试是这样做的。

```haskell
ghci> 5 == 5  
True  
ghci> 1 == 0  
False  
ghci> 5 /= 5  
False  
ghci> 5 /= 4  
True  
ghci> "hello" == "hello"  
True   
```

那么 `5 + "llama"` 和 `5 == True` 呢？如果我们测试第一个片段的话，就会得到一个很严重的错误消息。

```haskell
No instance for (Num [Char])  
arising from a use of `+' at <interactive>:1:0-9  
Possible fix: add an instance declaration for (Num [Char])  
In the expression: 5 + "llama"  
In the definition of `it': it = 5 + "llama"   
```

呵呵~GHCI告诉我们，"llama"不是数字，所以它并不知道怎么将其加到数字5上面。即使不是"llama"而是"four"或者是"4",Haskell还是无法认为它是数字。`+` 期望的是它左右边都是数字。如果我们试着 `True == 5`，GHCI 会告诉我们类型不匹配。`+` 只有是认为是数字才能进行运算，`==` 则是认为是两个可比较性的东西才能够运算。需要明白的一点是，必须是同一类型。你无法拿苹果跟橘子做比较。稍后我们将进一步研究类型。这里需要注意的是，你可以执行 `5+4.0` ，因为 `5` 很狡猾，既可以表现为整数也可以表现为浮点。`4.0` 并非整数，所以5只能去适应。

你可能不知道，其实我们一直在使用函数。例如，`*` 是一个将两个数字进行相乘的函数。正如你看到的，我们把它夹在数字之间。这就是我们所说的中缀函数。大多数与数字无关的函数都是前缀函数。让我们看一看。

函数一般都是前缀函数，之后我们就不明确表示函数是前缀形式。在大多数命令式语言中，函数是通过函数名和括号包起来的参数（通常用逗号隔开）调用的。在Haskell中，函数是通过函数名、空格、参数（有空格隔开）来调用的。首先，让我们试着调用Haskell史上最无聊的一个函数吧。

```haskell
ghci> succ 8  
9   
```

`succ` 函数接受任何有接替者的参数，并返回接替者。正如你所看到，我们只是用空格将函数名跟参数分开。调用一个多参数的函数也是很简单。函数 `min` 和 `max` ，取两个可以排序的参数（如数字）。 `min` 函数会返回较小的那个，而 `max` 函数会返回较大的那个。你瞄瞄看：

```haskell
ghci> min 9 10  
9  
ghci> min 3.4 3.2  
3.2  
ghci> max 100 101  
101   
```

函数应用程序（通过在它后面加一个空格来调用一个函数，然后再输入参数）具有最高的优先级。这对我们来说意味着这两个表达式是一样效果的。

```haskell
ghci> succ 9 + max 5 4 + 1  
16  
ghci> (succ 9) + (max 5 4) + 1  
16  
```

但是如果我们想得到9跟10的乘积的接替者，我们不能写 `succ 9*10` ,因为那样只会得到9的接替者，然后再乘以10.等到的是100.我们需要写成 `succ(9*10)` 得到91.

如果一个函数接受两个参数，我们也可以叫他是中缀函数，用到两个反引号括起来。比如，div函数将两个整型进行整除，`div 92 10` 结果是 9。但是当我们调用它的时候，可能会混淆，哪个是被除数，那个是除数。所以我们也可以用中缀函数的形式来表达，`92/`div/`10`,一目了然多了。

很多有过命令式语言经验小伙伴们倾向于认为圆括号应该用来表示函数。例如，在C语言中，你会用括号来调用如`foo()`、`bar(1)`或者是`baz(3,"haha")`之类的函数。正如我们说得，空格是用在Haskell函数内。所以这些函数在Haskell将会变成`foo`、`bar 1`还有 `baz 3 "haha"` 。所以如果你看到这样的函数调用 `bar(bar 3)` ,它并不是说 `bar` 被调用时传入 `3` 跟 `bar`两个参数。而是说第一次调用 `bar` 函数时传入参数 `3` 并获取返回结果，之后再调用一次 `bar` 并将之前的结果作为参数传进去。在C语言中，类似于bar(bar(3)) 。

## 第一个函数

在上一节中，我们对调用函数有一个感性的认识了。现在让我们来编写自己的函数吧！打开你最待见的一个文本编辑器，然后输入这个函数中输入一个数字，并将其乘以2。

```haskell
doubleMe x = x + x  
```

函数的定义方式有点类似调用。函数后面参数用空格隔开，但是定义函数的时候，有一个`=`用于定义函数的作用。保存在`baby.hs` 或者其他文件名。然后到保存这个文件的目录下，执行`ghci`。一旦进入到GHCI，执行 `:l baby` 。现在我们的脚本就已经加载进来，我们就可以使用我们定义的函数了。

```haskell
ghci> :l baby  
[1 of 1] Compiling Main             ( baby.hs, interpreted )  
Ok, modules loaded: Main.  
ghci> doubleMe 9  
18  
ghci> doubleMe 8.3  
16.6  
``` 

因为 `+` 处理整型跟浮点数（任何可以被认为真正是数字的数据），所以我们的函数也适用于操作任何数字。让我们再定义一个函数，取两个数字将它们乘以2，再进行相加。

```haskell
doubleUs x y = x*2 + y*2  
``` 

很简单吧！我们也可以将其定义为 `doubleUs x y = x + x + y + y`。测试出来的结果同样生成我们所预期的结果（要记得将这个函数加入到 `baby.hs` 文件中，保存后再进入GHCI执行 `:l` ）

```haskell
ghci> doubleUs 4 9  
26  
ghci> doubleUs 2.3 34.2  
73.0  
ghci> doubleUs 28 88 + doubleMe 123  
478  
``` 

正如我们预期的一样，你可以从在一个自定义函数里边调用其他自定义函数。如此考虑的话，我们也可以将 `doubleUs` 定义成如下:

```haskell
doubleUs x y = doubleMe x + doubleMe y   
``` 

这是一个非常简单的示例，在Haskell你会看到这种常见的定义模式。定义基本的函数，然后组合成更加复杂的函数。这种方法可以避免到重复造轮子。当数学家发现2其实是3的时候，你讲怎么修改你对程序呢？你只需要重新定义下 `doubleMe` 为 `x+x+x` ，这样 `doubleUs` 调用 `doubleMe` ，他就会自动在这新的世界里头得出2等于3。

Haskell中的函数是没有特定的顺序的，所以你不必在乎定义 `doubleMe` 还是 `doubleUs` 哪个先，或者是用其他方法去定义，这都不重要。

现在我们要定义一个函数，将一个数字乘以2，但是限制数字智能小于或等于100，因为大过100已经是够够的了。

```haskell
doubleSmallNumber x = if x > 100  
                        then x  
                        else x*2   
``` 

这里我们来介绍一下Haskell的 if 表达式。你可能对其他语言的if语句已经非常的熟悉了。跟命令式语言不同的一点是Haskell的if表达式中，else部分是必须的。在命令式语言中，如果条件不满足，你可以跳过这些步骤，但是在Haskell中，每个表达式和函数都必须返回。我们也可以将if条件语句写在一行中，我发现这样可读性更高些。if语句其实是表达式。表达式基本上是一段代码，并且返回值。5是一个表达式，所以它返回5。4 + 8 是表达式，x + y 是表达式，返回x和y的和，因为else是强制性的，一个if语句就总会返回值，这就是为什么它是表达式的原因。如果我们想在之前的函数返回的结果加上一个数字，我们可以像这样写结构体。

```haskell
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1  
``` 
如果我们省略括号的话，要加的数字就会加到不大于100的条件上去。在Haskell的语法中，引号没有特别的含义，它在一个函数名中使用的一个合法字符。我们通常使用引号去标记一个函数严格的版本（不惰性）或者是稍微修改过的一个函数或者是变量。因为反引号在函数中是一个合法的字符，我们可以这样来定义函数。

```haskell
conanO'Brien = "It's a-me, Conan O'Brien!"   
``` 

有两个值得注意的，第一个是是在函数命中，我们没有大写 `Conan` 的名字，这是因为函数中开始不能够用大写字母，我们在后面介绍这个。第二个是这个函数中没有使用任何参数。当一个函数美誉哦参数的时候，我们通常不叫做定义（或者是命名）。因为我们一旦我们定义了名字（或者是函数），就不能在修改，`conanO'Brien` 还有 字符串 `"It's a-me,Conan O'Brien!"` 可以互换使用。

## 列表

Haskell中，列表的作用就跟现实世界中购物清单一样有用。他是常用的数据结构，他可以通过多种不同方式来进行建模以及解决很多问题。列表真的很棒！在本节中，我们将看看，理解下列表、字符串（也属于列表）和列表的基础知识。

在Haskell中，列表是一个均匀的数据结构。它将几个相同类型的元素存储起来。这就意味着我们可以定义整型列表或者是字符串列表。但是我们不能将整型跟字符串混合成一个列表。小二，上一份列表来！

注意：我们可以使用let关键字在GHCI中定义一个名称。在GHCI中，`let a = 1` ，相当于在脚本中 `a=1` 并且加载它。

```haskell
ghci> let lostNumbers = [4,8,15,16,23,42]  
ghci> lostNumbers  
[4,8,15,16,23,42]  
```

如你所见，列表由方括号表示，列表中的值用逗号隔开。如果我们试着声明一个列表， `[1,2,'a',3,'b','c',4]` 的话，Haskell就要对字符BB了（顺便说下，字符是用单引号括起来的）。说到字符，字符串是字符的列表。`"hello"` 就是语法糖其实就是 `[h','e','l','l','o']` 。因为字符串是列表，所以我们可以使用列表的函数，非常方便。

一个常见的操作，将两个列表放在一起。这里通常用 `++` 运算符来完成操作。

```haskell
ghci> [1,2,3,4] ++ [9,10,11,12]  
[1,2,3,4,9,10,11,12]  
ghci> "hello" ++ " " ++ "world"  
"hello world"  
ghci> ['w','o'] ++ ['o','t']  
"woot"  
```

在长字符串中执行 `++` 操作的时候，要注意了！当你将两个列表放在一起（即使你将一个单独的列表加到另外一个列表中，例如 `[1,2,3] ++ [4]`）,在内部，Haskell必须去遍历 `++` 操作符左边整个的列表 。这样操作不是很大的列表的时候，其实也不是什么问题。但是如果你在一个5000万条目的列表末尾添加一些东西就需要一段时间了。然而，如果使用 `:` 运算符（也叫cons操作符）在列表开头添加内容，就是即时的。

注意：讲一个数字跟一个数字列表或者是说将一个字符跟一个字符列表，`++`针对的是两个列表，如果你要讲一个元素添加到一个列表中使用 `++` 运算符的话，你就必须用方括号将元素括起来，这样它就变成一个列表了。

`[1,2,3]`其实语法糖是 `1:2:3:[]` 。`[]` 是一个空列表。如果我们将 `3` 加在前面，就变成 `[3]` 如果我们在将 `2` 加在前面，就变成`[2,3]` ...

注意：`[]`、`[[]]`和`[[],[],[]]`是不同的东西，第一个是空列表，第二个是一个包含空列表的列表，第三个是一个包含三个空列表的列表。

如果你想从一个列表通过索引取出元素，可以使用 `!!` 操作符。坐标从0开始。

```haskell
ghci> "Steve Buscemi" !! 6  
'B'  
ghci> [9.4,33.2,96.2,11.2,23.25] !! 1  
33.2  
```

但是如果你想要从一个只有四个元素的列表中取出第六个元素的话，你就大错特错了！

列表中是可以包含子列表的，然后子列表又可以包含子列表...

```haskell
ghci> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
ghci> b  
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
ghci> b ++ [[1,1,1,1]]  
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]  
ghci> [6,6,6]:b  
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]  
ghci> b !! 2  
[1,2,2,3,4] 
```

列表下的子列表，长度可以不同，但是类型不能不同。就像一个列表不可以既有字符又有数字，你不能够声明一个既有字符子列表又有数字子列表的列表。

列表是可以进行比较的，如果它们是可比较性的话。当我们使用`<`,`<=`，`>=`去比较列表，他们会按照字典顺序进行比较。首先从第一个元素进行比较，如果它们相同的话，就对第二个元素进行比较，等等。

```haskell
ghci> [3,2,1] > [2,1,0]  
True  
ghci> [3,2,1] > [2,10,100]  
True  
ghci> [3,4,2] > [3,4]  
True  
ghci> [3,4,2] > [2,4]  
True  
ghci> [3,4,2] == [3,4,2]  
True  
```

列表还有哪些操作呢？下面来介绍列表的一些基本操作。

`head`函数返回列表的头部，基本上，头部就是第一个元素。

```haskell
ghci> head [5,4,3,2,1]  
5   
```

`tail`函数返回一个列表中的尾部，换句话所，就是剔除掉头部的那部分。

```haskell
ghci> tail [5,4,3,2,1]  
[4,3,2,1]   
```

`last`函数返回列表的最后一个元素

```haskell
ghci> last [5,4,3,2,1]  
1   
```

`init`返回剔除出最后一个元素的列表

```haskell
ghci> init [5,4,3,2,1]  
[5,4,3,2]   
```

如果我们把列表想象成为一条虫的话，就如同下图

<div align="center">

![](/images/chapter02/listmonster.png)

</div>

不过如果我们试着去从一个空列表中取出头部的话，会发生什么？

```haskell
ghci> head []  
*** Exception: Prelude.head: empty list   
```

噢，我的天呐！爆表了，这是！如果没有这条虫，所以它就不会有头部。所以当用到`head`、`tail`、`last`和`init`函数的时候，注意不要在空列表中使用到。这个错误在编译的时候是捕获不到的。最好的处理办法是，避免让Haskell从一个空列表中取元素。

`length`函数显然是返回列表的长度。

```haskell
ghci> length [5,4,3,2,1]  
5  
```

`null`检查列表是否为空。如果是将返回`True`使用这个函数来代替 `xs == []`(如果你声明为xs的列表)。

```haskell
ghci> null [1,2,3]  
False  
ghci> null []  
True  
```

`reverse`函数反向一个列表

```haskell
ghci> reverse [5,4,3,2,1]  
[1,2,3,4,5]  
```

`take`函数输入数字跟列表参数。它会获取列表从开头开始算个数的一个片段。

```haskell
ghci> take 3 [5,4,3,2,1]  
[5,4,3]  
ghci> take 1 [3,9,3]  
[3]  
ghci> take 5 [1,2]  
[1,2]  
ghci> take 0 [6,6,6]  
[]  
```

如果我们试着获取比原来列表还要多的元素，仅仅也是返回原来的列表。如果我们试着获取0个元素，我们将得到一个空列表。

`drop`函数是一个类似的方法，只是它是从列表开始到输入的数字进行剔除。

```haskell
ghci> drop 3 [8,4,2,1,5,6]  
[1,5,6]  
ghci> drop 0 [1,2,3,4]  
[1,2,3,4]  
ghci> drop 100 [1,2,3,4]  
[]   
```

`maximum`函数返回一个有可排序性的列表中最大的元素。

`minimum`函数返回最小的元素。

```haskell
ghci> minimum [8,4,2,1,5,6]  
1  
ghci> maximum [1,9,2,3,4]  
9   
```

`sum`函数是返回一个数字列表所有元素的总和。

`product`函数是返回一个数字列表所有元素的乘积。

```haskell
ghci> sum [5,2,1,6,3,2,5,7]  
31  
ghci> product [6,2,1,2]  
24  
ghci> product [1,2,5,6,7,9,2,0]  
0   
```

`elem`函数返回某元素是否属于某个列表。他通常被调用为中缀函数的形式，因为这样可读性比较高。

```haskell
ghci> 4 `elem` [3,4,5,6]  
True  
ghci> 10 `elem` [3,4,5,6]  
False  
```

这些是列表的一些基本操作，我们将会在以后再了解下列表的更多操作。传送门>>待翻译完后补充。

## 区间

如果我们想要声明一个所有数字为1-20的列表呢？当然，我们可以把他们全部打出来，但是很显然，对于编程语言有非常优秀追求的绅士们来说，这可不是一个好的方法。我们可以使用区间来解决。区间可以列出可枚举元素的算术序列。数字是可枚举的，1,2,3,4等等。字符也是可枚举的。字母是从A-Z的枚举字符。名称则无法枚举。“John”后面是什么，鬼才知道！

定义一个包含从1-20的自然数的列表，你只需要写成 `[1..20]` 。这就等价于写成 `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]` ,这两种写法没有什么区别，只是手写一个那么长的序列，多少有点傻得可爱。

```haskell
ghci> [1..20]  
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]  
ghci> ['a'..'z']  
"abcdefghijklmnopqrstuvwxyz"  
ghci> ['K'..'Z']  
"KLMNOPQRSTUVWXYZ"
```

区间很酷，你甚至可以指定一个阶段，如果我们想要一个1-20的偶数？或者是1-20说3的倍数。

```haskell
ghci> [2,4..20]  
[2,4,6,8,10,12,14,16,18,20]  
ghci> [3,6..20]  
[3,6,9,12,15,18]  
``` 

只是用逗号将两个元素隔开，然后指定上限是多少。虽然这样相当聪明，但是阶段区间并非像人期望的那么聪明。你不能用`[1,2,3,8,16..100]` 去期望他得到2的所有指数值。首先你只能够指定一个特定的阶段。第二，一些没有规则的序列如果只给他们第一个条件的话，是比较含糊不清的。

要想得到一个20到1的所有数字，不能只是 `[20..1]` ,你必须这样处理，`[20,19..1]`。

使用浮点时就要小心了！因为它们无法完全精确（根据定义），在区间的使用过程中可能会产生一些非常有趣的结果。

```haskell
ghci> [0.1, 0.3 .. 1]  
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]  
``` 

我的建议是列表区间中不要使用浮点。

你也可以使用区间去定义一个无限列表，只要不指定上限。后面我们将详细介绍一下无下限列表。现在，让我们来看看如何获取13的1到24倍。当然你可以这样做 `[13,26..24*13]` 。但是有一个更好的方法是 `24[13,26..]` 。Haskell是惰性的，它不会立马去评估一个无限列表，因为永远不可能结束。 它会等着看你想要从无限列表中得到什么。这里它看到你只是想要前面24个元素，它才非常乐意去干活。


一些产生无限列表的函数：

`cycle`函数输入一个列表，转换成无限列表，如果你只是想显示出结果，那它将会永远执行下去，所以你最好去将它截取。

```haskell
ghci> take 10 (cycle [1,2,3])  
[1,2,3,1,2,3,1,2,3,1]  
ghci> take 12 (cycle "LOL ")  
"LOL LOL LOL "   
```

`repeat`函数输入一个元素，会产生一个只有这个元素的无限列表。这就很像cycle出来无限列表，只是用到的是一个元素。

```haskell
ghci> take 10 (repeat 5)  
[5,5,5,5,5,5,5,5,5,5] 
```

既然你想要获取到一些相同元素是数字的列表，那么使用`replicate`函数会更加简单些，`replicate 3 10` 返回 `[10,10,10]`。