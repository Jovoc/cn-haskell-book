# 开始着手

## 全军出击

好吧，我们出发吧！如果你是一个讨厌的家伙，居然不看上一章介绍就跳过了，你可能也会看看介绍里边最后的一部分，因为它提到你需要学习本教程需要准备的一些东西，还有我们是如何加载函数的。我们要做的第一件事情就是执行ghc的交互模式，并且调用函数去获取对baskell一些感性认识。现在就可以打开终端，输入ghci命令。你将会收到这样的问候。

```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help  
Loading package base ... linking ... done.  
Prelude>  
```

恭喜你，你已经进入GHCI了！这里提示 `Prelude>`，但当你加载东西到回话中的话，显示的信息会变得更多些。这里，我们将使用 `ghci>` 如果你想拥有相同的提示，只需要输入 `:set prompt "ghci>"`。

这里有一些简单计算，我们来看下

```haskell
ghci> 2 + 15  
17  
ghci> 49 * 100  
4900  
ghci> 1892 - 1472  
420  
ghci> 5 / 2  
2.5  
ghci>  
```

这是不言自明的。我们还可以在一行上使用多个操作符，并且遵守所有通常的优先规则。我们可以使用括号来明确优先级或更改优先级。

```haskell
ghci> (50 * 100) - 4999  
1  
ghci> 50 * 100 - 4999  
1  
ghci> 50 * (100 - 4999)  
-244950   
```

酷不?当然，可能不是很酷，当我觉得已经很酷了。这里要注意的一点是负数。如果我们想用负数，最好是用括号括起来。如果输入 `5 * -3` ,GHCI会对你咆哮，如果是 `5 *(-3)` 则没有什么问题。

布尔代数也很简单。你可能已经知道，&&代表的是并，||代表或，not代表否定。

```haskell
ghci> True && False  
False  
ghci> True && True  
True  
ghci> False || True  
True   
ghci> not False  
True  
ghci> not (True && True)  
False   
```

对平等的测试是这样做的。

```haskell
ghci> 5 == 5  
True  
ghci> 1 == 0  
False  
ghci> 5 /= 5  
False  
ghci> 5 /= 4  
True  
ghci> "hello" == "hello"  
True   
```

那么 `5 + "llama"` 和 `5 == True` 呢？如果我们测试第一个片段的话，就会得到一个很严重的错误消息。

```haskell
No instance for (Num [Char])  
arising from a use of `+' at <interactive>:1:0-9  
Possible fix: add an instance declaration for (Num [Char])  
In the expression: 5 + "llama"  
In the definition of `it': it = 5 + "llama"   
```

呵呵~GHCI告诉我们，"llama"不是数字，所以它并不知道怎么将其加到数字5上面。即使不是"llama"而是"four"或者是"4",Haskell还是无法认为它是数字。`+` 期望的是它左右边都是数字。如果我们试着 `True == 5`，GHCI 会告诉我们类型不匹配。`+` 只有是认为是数字才能进行运算，`==` 则是认为是两个可比较性的东西才能够运算。需要明白的一点是，必须是同一类型。你无法拿苹果跟橘子做比较。稍后我们将进一步研究类型。这里需要注意的是，你可以执行 `5+4.0` ，因为 `5` 很狡猾，既可以表现为整数也可以表现为浮点。`4.0` 并非整数，所以5只能去适应。

你可能不知道，其实我们一直在使用函数。例如，`*` 是一个将两个数字进行相乘的函数。正如你看到的，我们把它夹在数字之间。这就是我们所说的中缀函数。大多数与数字无关的函数都是前缀函数。让我们看一看。

函数一般都是前缀函数，之后我们就不明确表示函数是前缀形式。在大多数命令式语言中，函数是通过函数名和括号包起来的参数（通常用逗号隔开）调用的。在Haskell中，函数是通过函数名、空格、参数（有空格隔开）来调用的。首先，让我们试着调用Haskell史上最无聊的一个函数吧。

```haskell
ghci> succ 8  
9   
```

`succ` 函数接受任何有接替者的参数，并返回接替者。正如你所看到，我们只是用空格将函数名跟参数分开。调用一个多参数的函数也是很简单。函数 `min` 和 `max` ，取两个可以排序的参数（如数字）。 `min` 函数会返回较小的那个，而 `max` 函数会返回较大的那个。你瞄瞄看：

```haskell
ghci> min 9 10  
9  
ghci> min 3.4 3.2  
3.2  
ghci> max 100 101  
101   
```

函数应用程序（通过在它后面加一个空格来调用一个函数，然后再输入参数）具有最高的优先级。这对我们来说意味着这两个表达式是一样效果的。

```haskell
ghci> succ 9 + max 5 4 + 1  
16  
ghci> (succ 9) + (max 5 4) + 1  
16  
```

但是如果我们想得到9跟10的乘积的接替者，我们不能写 `succ 9*10` ,因为那样只会得到9的接替者，然后再乘以10.等到的是100.我们需要写成 `succ(9*10)` 得到91.

如果一个函数接受两个参数，我们也可以叫他是中缀函数，用到两个反引号括起来。比如，div函数将两个整型进行整除，`div 92 10` 结果是 9。但是当我们调用它的时候，可能会混淆，哪个是被除数，那个是除数。所以我们也可以用中缀函数的形式来表达，`92/`div/`10`,一目了然多了。

很多有过命令式语言经验小伙伴们倾向于认为圆括号应该用来表示函数。例如，在C语言中，你会用括号来调用如`foo()`、`bar(1)`或者是`baz(3,"haha")`之类的函数。正如我们说得，空格是用在Haskell函数内。所以这些函数在Haskell将会变成`foo`、`bar 1`还有 `baz 3 "haha"` 。所以如果你看到这样的函数调用 `bar(bar 3)` ,它并不是说 `bar` 被调用时传入 `3` 跟 `bar`两个参数。而是说第一次调用 `bar` 函数时传入参数 `3` 并获取返回结果，之后再调用一次 `bar` 并将之前的结果作为参数传进去。在C语言中，类似于bar(bar(3)) 。

## 第一个函数

在上一节中，我们对调用函数有一个感性的认识了。现在让我们来编写自己的函数吧！打开你最待见的一个文本编辑器，然后输入这个函数中输入一个数字，并将其乘以2。

```haskell
doubleMe x = x + x  
```

函数的定义方式有点类似调用。函数后面参数用空格隔开，但是定义函数的时候，有一个`=`用于定义函数的作用。保存在`baby.hs` 或者其他文件名。然后到保存这个文件的目录下，执行`ghci`。一旦进入到GHCI，执行 `:l baby` 。现在我们的脚本就已经加载进来，我们就可以使用我们定义的函数了。

```haskell
ghci> :l baby  
[1 of 1] Compiling Main             ( baby.hs, interpreted )  
Ok, modules loaded: Main.  
ghci> doubleMe 9  
18  
ghci> doubleMe 8.3  
16.6  
``` 

因为 `+` 处理整型跟浮点数（任何可以被认为真正是数字的数据），所以我们的函数也适用于操作任何数字。让我们再定义一个函数，取两个数字将它们乘以2，再进行相加。

```haskell
doubleUs x y = x*2 + y*2  
``` 

很简单吧！我们也可以将其定义为 `doubleUs x y = x + x + y + y`。测试出来的结果同样生成我们所预期的结果（要记得将这个函数加入到 `baby.hs` 文件中，保存后再进入GHCI执行 `:l` ）

```haskell
ghci> doubleUs 4 9  
26  
ghci> doubleUs 2.3 34.2  
73.0  
ghci> doubleUs 28 88 + doubleMe 123  
478  
``` 

正如我们预期的一样，你可以从在一个自定义函数里边调用其他自定义函数。如此考虑的话，我们也可以将 `doubleUs` 定义成如下:

```haskell
doubleUs x y = doubleMe x + doubleMe y   
``` 

这是一个非常简单的示例，在Haskell你会看到这种常见的定义模式。定义基本的函数，然后组合成更加复杂的函数。这种方法可以避免到重复造轮子。当数学家发现2其实是3的时候，你讲怎么修改你对程序呢？你只需要重新定义下 `doubleMe` 为 `x+x+x` ，这样 `doubleUs` 调用 `doubleMe` ，他就会自动在这新的世界里头得出2等于3。

Haskell中的函数是没有特定的顺序的，所以你不必在乎定义 `doubleMe` 还是 `doubleUs` 哪个先，或者是用其他方法去定义，这都不重要。

现在我们要定义一个函数，将一个数字乘以2，但是限制数字智能小于或等于100，因为大过100已经是够够的了。

```haskell
doubleSmallNumber x = if x > 100  
                        then x  
                        else x*2   
``` 

这里我们来介绍一下Haskell的 if 表达式。你可能对其他语言的if语句已经非常的熟悉了。跟命令式语言不同的一点是Haskell的if表达式中，else部分是必须的。在命令式语言中，如果条件不满足，你可以跳过这些步骤，但是在Haskell中，每个表达式和函数都必须返回。我们也可以将if条件语句写在一行中，我发现这样可读性更高些。if语句其实是表达式。表达式基本上是一段代码，并且返回值。5是一个表达式，所以它返回5。4 + 8 是表达式，x + y 是表达式，返回x和y的和，因为else是强制性的，一个if语句就总会返回值，这就是为什么它是表达式的原因。如果我们想在之前的函数返回的结果加上一个数字，我们可以像这样写结构体。

```haskell
doubleSmallNumber' x = (if x > 100 then x else x*2) + 1  
``` 
如果我们省略括号的话，要加的数字就会加到不大于100的条件上去。在Haskell的语法中，引号没有特别的含义，它在一个函数名中使用的一个字符。我们通常使用引号去标记一个函数严格的版本（不惰性）或者是稍微修改过的一个函数或者是变量。因为反引号在函数中是一个合法的字符，我们可以这样来定义函数。

```haskell
conanO'Brien = "It's a-me, Conan O'Brien!"   
``` 

有两个值得注意的，第一个是是在函数命中，我们没有大写 `Conan` 的名字，这是因为函数中开始不能够用大写字母，我们在后面介绍这个。第二个是这个函数中没有使用任何参数。当一个函数美誉哦参数的时候，我们通常不叫做定义（或者是命名）。因为我们一旦我们定义了名字（或者是函数），就不能在修改，`conanO'Brien` 还有 字符串 `"It's a-me,Conan O'Brien!"` 可以互换使用。