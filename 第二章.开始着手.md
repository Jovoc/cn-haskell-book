# 开始着手

## 全军出击

好吧，我们出发吧！如果你是一个讨厌的家伙，居然不看上一章介绍就跳过了，你可能也会看看介绍里边最后的一部分，因为它提到你需要学习本教程需要准备的一些东西，还有我们是如何加载函数的。我们要做的第一件事情就是执行ghc的交互模式，并且调用函数去获取对baskell一些感性认识。现在就可以打开终端，输入ghci命令。你将会收到这样的问候。

```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help  
Loading package base ... linking ... done.  
Prelude>  
```

恭喜你，你已经进入GHCI了！这里提示 `Prelude>`，但当你加载东西到回话中的话，显示的信息会变得更多些。这里，我们将使用 `ghci>` 如果你想拥有相同的提示，只需要输入 `:set prompt "ghci>"`。

这里有一些简单计算，我们来看下

```haskell
ghci> 2 + 15  
17  
ghci> 49 * 100  
4900  
ghci> 1892 - 1472  
420  
ghci> 5 / 2  
2.5  
ghci>  
```

这是不言自明的。我们还可以在一行上使用多个操作符，并且遵守所有通常的优先规则。我们可以使用括号来明确优先级或更改优先级。

```haskell
ghci> (50 * 100) - 4999  
1  
ghci> 50 * 100 - 4999  
1  
ghci> 50 * (100 - 4999)  
-244950   
```

酷不?当然，可能不是很酷，当我觉得已经很酷了。这里要注意的一点是负数。如果我们想用负数，最好是用括号括起来。如果输入 `5 * -3` ,GHCI会对你咆哮，如果是 `5 *(-3)` 则没有什么问题。

布尔代数也很简单。你可能已经知道，&&代表的是并，||代表或，not代表否定。

```haskell
ghci> True && False  
False  
ghci> True && True  
True  
ghci> False || True  
True   
ghci> not False  
True  
ghci> not (True && True)  
False   
```

对平等的测试是这样做的。

```haskell
ghci> 5 == 5  
True  
ghci> 1 == 0  
False  
ghci> 5 /= 5  
False  
ghci> 5 /= 4  
True  
ghci> "hello" == "hello"  
True   
```

那么 `5 + "llama"` 和 `5 == True` 呢？如果我们测试第一个片段的话，就会得到一个很严重的错误消息。

```haskell
No instance for (Num [Char])  
arising from a use of `+' at <interactive>:1:0-9  
Possible fix: add an instance declaration for (Num [Char])  
In the expression: 5 + "llama"  
In the definition of `it': it = 5 + "llama"   
```

呵呵~GHCI告诉我们，"llama"不是数字，所以它并不知道怎么将其加到数字5上面。即使不是"llama"而是"four"或者是"4",Haskell还是无法认为它是数字。`+` 期望的是它左右边都是数字。如果我们试着 `True == 5`，GHCI 会告诉我们类型不匹配。`+` 只有是认为是数字才能进行运算，`==` 则是认为是两个可比较性的东西才能够运算。需要明白的一点是，必须是同一类型。你无法拿苹果跟橘子做比较。稍后我们将进一步研究类型。这里需要注意的是，你可以执行 `5+4.0` ，因为 `5` 很狡猾，既可以表现为整数也可以表现为浮点。`4.0` 并非整数，所以5只能去适应。

你可能不知道，其实我们一直在使用函数。例如，`*` 是一个将两个数字进行相乘的函数。正如你看到的，我们把它夹在数字之间。这就是我们所说的中缀函数。大多数与数字无关的函数都是前缀函数。让我们看一看。

函数一般都是前缀函数，之后我们就不明确表示函数是前缀形式。在大多数命令式语言中，函数是通过函数名和括号包起来的参数（通常用逗号隔开）调用的。在Haskell中，函数是通过函数名、空格、参数（有空格隔开）来调用的。首先，让我们试着调用Haskell史上最无聊的一个函数吧。

```haskell
ghci> succ 8  
9   
```

`succ` 函数接受任何有接替者的参数，并返回接替者。正如你所看到，我们只是用空格将函数名跟参数分开。调用一个多参数的函数也是很简单。函数 `min` 和 `max` ，取两个可以排序的参数（如数字）。 `min` 函数会返回较小的那个，而 `max` 函数会返回较大的那个。你瞄瞄看：

```haskell
ghci> min 9 10  
9  
ghci> min 3.4 3.2  
3.2  
ghci> max 100 101  
101   
```

函数应用程序（通过在它后面加一个空格来调用一个函数，然后再输入参数）具有最高的优先级。这对我们来说意味着这两个表达式是一样效果的。

```haskell
ghci> succ 9 + max 5 4 + 1  
16  
ghci> (succ 9) + (max 5 4) + 1  
16  
```

但是如果我们想得到9跟10的乘积的接替者，我们不能写 `succ 9*10` ,因为那样只会得到9的接替者，然后再乘以10.等到的是100.我们需要写成 `succ(9*10)` 得到91.

如果一个函数接受两个参数，我们也可以叫他是中缀函数，用到两个反引号括起来。比如，div函数将两个整型进行整除，`div 92 10` 结果是 9。但是当我们调用它的时候，可能会混淆，哪个是被除数，那个是除数。所以我们也可以用中缀函数的形式来表达，`92/`div/`10`,一目了然多了。

很多有过命令式语言经验小伙伴们倾向于认为圆括号应该用来表示函数。例如，在C语言中，你会用括号来调用如`foo()`、`bar(1)`或者是`baz(3,"haha")`之类的函数。正如我们说得，空格是用在Haskell函数内。所以这些函数在Haskell将会变成`foo`、`bar 1`还有 `baz 3 "haha"` 。所以如果你看到这样的函数调用 `bar(bar 3)` ,它并不是说 `bar` 被调用时传入 `3` 跟 `bar`两个参数。而是说第一次调用 `bar` 函数时传入参数 `3` 并获取返回结果，之后再调用一次 `bar` 并将之前的结果作为参数传进去。在C语言中，类似于bar(bar(3)) 。