# 递归

## 你好，递归

上一章节中，我们简单地提及到递归的概念，在这一节中，我们会更近距离去了解并使用`递归`。思考两个问题，一.为什么在`Haskell`
中`递归`是如此重要，二.如何使用递归的思想实现出简明和优雅的解决方案。

如果你依然不知道`递归`是什么，请阅读这个语句，哈哈，只是开玩笑啦(ps: 外国人的冷笑话，一点也不好笑，@_@!)。`递归`实际上是
一种在定义函数时，在函数的内部再次去调用该函数的方法。在数学上的定义往往是使用递归的。比如一个`斐波那契数列`就是使用递归
定义的。首先，我们不使用递归，定义两个斐波那契数列的前两个数字。我们可以说`F(0)=0`和`F(1)=1`，意味着第1个和第2个数字分别
为0和1。然后，我们说其它的数字是该数字前面两个数字的和。所以`F(n)=F(n-1)+F(n-2)`。这样`F(3)`就是`F(2)+F(1)`，也就是`F(3)=(F(1)+F(0))+F(0)`。
因为我们现在说过不使用递归来定义`斐波那契数列`，那我们可以简单地说`F(3)=2`。在递归定义中有一个或两个不是使用递归的元素
(如`F(0)`和`F(1)`)，这里我们它们为`边界条件`，这对于什么时候函数终止非常重要。如果我们使用递归的方式定义`F(0)`和`F(1)`，
我们将得不到任何的数字，因为当函数到达为0的时候，将会去计算负数。如果这些发生，你可能会说` F(-2000)= F(-2001) + F(-2002)`，
但这样程序将无法终止。

在`Haskell`中，`递归`十分重要，不像其它命令式语言中(过程式语言，指令按顺逐一执行)，通过递归，你在计算时，只需要定义如何
去做，而不需要如何才能得到这些数据。这也是为什么在`Haskell`中没有`while`语句和`for`语句，因为你可以使用`递归`的思想去实现
它们。

## 最大数

`maximum`方法从一个可以排序的列表(是`Ord`类型类的实例)中，返回其中最大的一个。想像一下，你如何在交互式的操作下实现这一功
能。你可能会选择目前为止最大的数与其余的值逐个去比较，如果比当前最大值还要大，则将这个值做为目前最大值。一直按这个逻辑持
续到列表的最后的那个当前最大值就是列表中的最大值。哈，一个简单地算法却使用了这么多的语言...

现在让我们学习如何使用递归去定义它。(ps:#1)。首先我们设置边界条件，我们说如果列表中只有一个元素，则这个元素就是我们所需求
得的最大值。然后如果表头元素比表尾列表中的最大值还要大，则称这个表头元素为最大值。如果表尾元素中的最大值更大些，则认定该
值为最大值。没错，就只有这些。现在让我们用`Haskell`实现之。

(ps.#1 首先需要理解列表头和尾的概念，列表的第一个元素称为`表头`，除了第一个元素的其余元素组成的列表称为`表尾`，`表尾`是一
个列表，没元素，表示为`[]`)

```haskell
maximum' :: (Ord a) => [a] -> a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs)   
    | x > maxTail = x  
    | otherwise = maxTail  
    where maxTail = maximum' xs 
```

正如你所见，在递归中，模式匹配运行得非常好。绝大多数没有模式匹配的命令式语言就需要一大堆的`if`、`while`语句作为其终止条
件。这里，我们以模式的方式，简单地作些解释。第一个边界条件`maximum' [] = error "maximum of empty list" `，如果列表为空，则
提示当中的语句。因为我们不知道在空的列表中，什么值会是最大的#_#!。第二个模式还是给出了一个边界条件，如果在列表只有一个元
素，则返回这个唯一元素即可。

第三个条件是操作发时需要满足的条件。我们使用模式匹配将一个列表分割成表头和表尾。在列表上应用递归时，这是一个常用的技巧，
去学习使用它吧。我们使用一个`where`绑定去定义一个变量`maxTail`作为表尾元素中最大的元素，然后我们检查表头元素是否大于这个
变量，如果是返回表头元素，如果不是返回该变量。

现在我们使用一个示例`[2,5,1]`，验证是否解出最大值。如果我们调用`maximum`，前两个模式不能成功匹配，第三个模式会将列表分割
成`2`和`[5,1]`，`where`从句想要知道`[5,1]`中哪个是最大值。按照这个逻辑，它再一次匹配到第三个模式，并将`[5,1]`分割成`5`和
`[1]`，且`where`从句想要知道`[1]`中的最大值。因为这个一个边界条件，它会返回`1`。然后向上执行，比较`5`和`[1]`中的最大值(也
就是`1`)，很显然，我们得到`5`为最大值。现在我们已经知道`[5,1]`中的最大值为`5`，再次比较`2`和`[5,1]`中的最大值(也就是`5`)，
还是选择`5`作为最大值。

另外可以用`max`方法，更清晰的方法去实现这个功能。记住，`max`是比较两个数字，返回较大的一个。现在使用`max`去重写`maximum`。

```haskell
maximum' :: (Ord a) => [a] -> a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs) = max x (maximum' xs)  
```

这是多么的优雅！其本质在于，列表的第一个元素和其表尾元素中的最大值的较大都即为该列表的最大值。

<div align="center">

![](/images/chapter05/maxs.png)

</div>

## 更多的递归函数

现在，我们知道如何去递归地思考问题。那让我们使用递归去实现一些方法。如`replicate`，`replicate`使用一个`Int`类型的值`n`，
和另一个元素`e`，返回一个包含`n`个`e`的列表。比如，`replicate 3 5`返回`[5,5,5]`。思考一下边界条件。我们的想法是作为边界
条件，那`n`的值为`0`或者更小。如果重复一个元素`0`次，它返回一个空的列表。而对于负数，它其实并没有起到任何作用。

```haskell
replicate' :: (Num i, Ord i) => i -> a -> [a]  
replicate' n x  
    | n <= 0    = []  
    | otherwise = x:replicate' (n-1) x  
```

因为要测试一个`boolean`的条件，这里我们使用`|`来代替模式匹配。如果`n`等于`0`或者小于`0`，返回一个空的列表。否则返回一个
第一个元素为`x`为表头，`n-1`个元素为`x`的表尾，显然，`n-1`的代码又会执行到这个方法，直到到达边界条件。

> `Num`不是`Ord`的子类，这意味着数字不支持排序的性质，所以在执行加法和减法及比较中同时指出`Num`和`Ord`类型。

接下来，我们将实现`take`。该方法用于从元素列表中选取待定个数的元素，并组成列表。比如，`take 3 [5,4,3,2,1]`，会返回`[5,4,3]`。
如果我们从`0`个或更少的列表中选取，则会返回一个空的列表。另外，如果我们从一个空的列表中选择，依然会得到一个空的列表。注意，
这两个边界条件都是必要且正确的。那将它写出来吧。

```haskell
take' :: (Num i, Ord i) => i -> [a] -> [a]  
take' n _  
    | n <= 0   = []  
take' _ []     = []  
take' n (x:xs) = x : take' (n-1) xs  
```

第一个模式说明了，如果我们取`0`个或者负数个元素，将返回一个空的列表。注意，因为我们不需要去关心传进行的参数是什么，所以
我们使用`_`去匹配一个列表。也要注意，我们使用`|`且没有使用`otherwise`从句。也就是当`n`大于0时，会顺着逻辑进行下一个模式中。
第二个说明如果从一个空列表中取，返回一个空列表。第三个模式将列表分割成表头和表尾，然后取`n`个元素的列表，相当于从取一个表
头元素和`n-1`个表尾中的元素组成的列表。请拿出一张纸，思考下使用`take 3 [4,3,2,1]`的执行逻辑。


`reverse`就是将一个列表反转。想像一下边界条件。是什么？动起来想哦(#_#!)。没错，就是空列表。空的列表反转就是自己，还是一个
空的列表。那其余的那些列表呢？那你可以会想到将一个列表分割成表头和表尾。反转相当于将表尾再一次反转，将表头作为列表的最后
一个元素。

```haskell
reverse' :: [a] -> [a]  
reverse' [] = []  
reverse' (x:xs) = reverse' xs ++ [x]
```

^_^，没错，就是这样。


因为`Haskell`支持定义无限循环的列表，那这个递归中的边界条件没有真正地达到这个条件。对于无限列表，没如果真没达到边界条件，
那程序将无限循环地执行，产生无限的输出。那更好的办法就是从无限列表中去切割我们所需要的部分。递归地使用`repeat`可以返回一
个无限列表，使用递归去说明，确实很简单。

```haskell
repeat' :: a -> [a]  
repeat' x = x:repeat' x
```
调用`repeat 3`将会返回以`3`为开头，和以无数个`3`组成的表尾的无限列表。所以调用`repeat 3`相当于`3:repeat 3`、`3:(3:repeat 3)`等等。
`repeat 3`会一直计算，那使用`take 5 (repeat 3)`会返回一个包含5个`3`的列表。事实上，它的就相当于`replicate 5 3`。

`zip`操作使用两个列表，并将两个列表中的元素分别组合起来。`zip [1,2,3] [2,3]`返回`[(1,2),(2,3)]`，该操作会去除长度较长者的
其它元素，只匹配较短的列表。那如果在空列表中应用该方法又会怎么样呢？当然，我们会得到一个空的列表，这就是我们的边界条件。
但是，`zip`有两个操作列表，那么相应的有两个边界条件。

```haskell
zip' :: [a] -> [b] -> [(a,b)]  
zip' _ [] = [] -- 第一个模式  
zip' [] _ = [] -- 第二个模式
zip' (x:xs) (y:ys) = (x,y):zip' xs ys 
```

首先，前两个模式中，如果第一个或第二个列表为空的时候，我们得到一个空的列表。第三个模式说明，操作两个列表相当于取两个列表
的头元素组成一对，并按这种方式应用在余下的表尾中。比如`zip [1,2,3] ['a','b']`最后会操作到`[3]`和`[]`。满足边界条件，其中
一个列表为空，则返回`(1,'a'):(2,'b'):[]`，表达方式等同于`[(1,'a'),(2,'b')]`。

现在让我们去实现另一个标准内置方法`elem`，用于查找一个元素是否在一个列表中。那作为边界条件，显然就是空列表。我们知道一个
空的列表没有任何元素，其中没有我们要找的元素。

```haskell
elem' :: (Eq a) => a -> [a] -> Bool  
elem' a [] = False  
elem' a (x:xs)  
    | a == x    = True  
    | otherwise = a `elem'` xs
```

正如我们所想的那么简单!如果查找的元素不是表头元素，那我们从表尾中去查找。直到执行到最后一个空的列表时，返回`False`。

## 快速排序

现在，我们需要将一个列表排序，该列表由一组相同类型元素组成，且可以排序，它们的类型都是`Ord`的一个实例。有一个很好的排序算
法，叫做`快速排序`，排序的思路非常清晰。在其它命令式的语言中可能需要10行以上的代码才能去实现这个功能，但在`Haskell`中，代
码更加简短且十分优雅。快速排序已然成为使用`Haskell`的典型应用场景。使用`Haskell`实现快速排序十分简单，任何人都可以优雅地
写出算法的实现。

类型签名为`quicksort :: (Ord a) => [a] -> [a]`，请不要惊奇，为什么没边界条件？通过先前的描述，空的列表显然就是边界条件。
空的列表做完排序操作返回的是一个空的列表。主要的算法逻辑如下：一个已排序的列表，其所有的元素都小于或等于其头一个元素(其中
除了头一个元素后的列表也是已排序的)，接下来的就是余下元素列表依然满足刚才的条件，所有元素小于或等于余下元素列表的第一个元
素。我们在上面的算法中强调了两次排序，所以我们可能需要在程序中递归调用两次。还有需要注意，我们在定义中只说明`什么是什么`的
问题，而没有具体地给出该怎么做、如何做，这正是该算法优雅的地方。现在需要在列表中过滤哪些元素比表头小，哪些数据比表头大。
现在就使用列表推导式来定义这个方法。

```haskell
quicksort :: (Ord a) => [a] -> [a]  
quicksort [] = []  
quicksort (x:xs) =   
    let smallerSorted = quicksort [a | a <- xs, a <= x]  
        biggerSorted = quicksort [a | a <- xs, a > x]  
    in  smallerSorted ++ [x] ++ biggerSorted  
```

做一个小小的测试，验证其正确性

```haskell
ghci> quicksort [10,2,5,3,1,6,7,4,2,3,4,8,9]  
[1,2,2,3,3,4,4,5,6,7,8,9,10]

ghci> quicksort "the quick brown fox jumps over the lazy dog"  
"        abcdeeefghhijklmnoooopqrrsttuuvwxyz" 
```

哇!这正如我们描述的一样。如我们有`[5,1,9,4,6,7,3]`，需要进行排序，算法会选择第一个表头元素`5`，将该元素放在当中，小于`5`
的在其左边，大于`5`的在其右边，所以有某一时刻，我们会得到`[1,4,3] ++ [5] ++ [9,6,7]`。因为有3个元素比`5`小所，当排序未完
成后，`5`会位于列表中的第4位。现在还需要去排序`[1,4,3]`和`[9,6,7]`。对于这两个列表中的排序算法和刚才的一模一样!当到达边
界条件时，我们中断程序的执行。如下下图说明：

<div align="center">

![](/images/chapter05/quicksort.png)

</div>

使用橘黄色标记的元素在一次排序后，它在列表中所在的位置将不会改变。如果你从左到右看，你会看一个已经排序的列表。我们选择所
有元素与头元素比较，头元素会进行多次比较。在快速排序中，一个需要多次与之比较的元素叫做轴。图中绿色部分就是。为什么我们选
择从表头元素开始，因为表头元素容易选择且容易进行匹配。浅绿色的元素都是比这个轴元素小的元素，深绿色的那些元素都比轴元素大。
这些黄色区域向下执行，表示着快速排序过程中程序执行的逻辑。


## 递归的思考

目前介绍了关于递归的一些内容，你可能注意到，递归有一种固有的模式。通常你需要定义一个边界条件，然后定义一个方法，应用于个
别元素和且同样适用于其余的元素。递归思想不需要关注数据类型是列表、树或其它数据类型。如果一个求和操作就是第一个元素和其余
元素和的和，如列表操作的结果就是第一个元素与其余元素操作结果的结果。如列表的长度就是1加上表尾的长度。

当然，这些都需要边界条件，这些边界条件往往是递归不能再继续执行的情况。如当处理列表时，它的边界条件往往是当列表为空的时候。
当处理树型结构时，边界条件往往是到达该结点为叶子结点的时候(即该结点没有子结点)。

这些和我们处理数值计算的递归相似，通常我们需要处理一些经常过程序改变后的值，且该值具有一定的规律。如果在处理阶乘时，其结
果为一个数值和剩余数值的阶乘，该递归函数对0不起作用，因为阶乘的运算只是定义在正数集合上。而边界条件是唯一的，阶乘运算的
边界条件就是`1`，在`1`上应用阶乘操作还是`1`。同样对于求和操作，定义空的列表的和为`0`。在快速排序中，定义的边界条件为遇到
空的列表，因为往一个列表加入一个空的列表还是得到原始列表。

所以当我们思考如何使用递归去解决某些实际问题，尝试去思考，递归的过程在满足什么样的边界条件时将不再执行，思考如何去拆分传
入的参数(比如列表，往往是将列表拆成表头和表尾)，紧接着再次调用原方法。







