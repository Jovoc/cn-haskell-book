# 递归

## 你好，递归

上一章节中，我们简单地提及到递归的概念，在这一节中，我们会更近距离去了解并使用`递归`。思考两个问题，一.为什么在`Haskell`
中`递归`是如此重要，二.如何使用递归的思想实现出简明和优雅的解决方案。

如果你依然不知道`递归`是什么，请阅读这个语句，哈哈，只是开玩笑啦(ps: 外国人的冷笑话，一点也不好笑，@_@!)。`递归`实际上是
一种在定义函数时，在函数的内部再次去调用该函数的方法。在数学上的定义往往是使用递归的。比如一个`斐波那契数列`就是使用递归
定义的。首先，我们不使用递归，定义两个斐波那契数列的前两个数字。我们可以说`F(0)=0`和`F(1)=1`，意味着第1个和第2个数字分别
为0和1。然后，我们说其它的数字是该数字前面两个数字的和。所以`F(n)=F(n-1)+F(n-2)`。这样`F(3)`就是`F(2)+F(1)`，也就是`F(3)=(F(1)+F(0))+F(0)`。
因为我们现在说过不使用递归来定义`斐波那契数列`，那我们可以简单地说`F(3)=2`。在递归定义中有一个或两个不是使用递归的元素
(如`F(0)`和`F(1)`)，这里我们它们为`边界条件`，这对于什么时候函数终止非常重要。如果我们使用递归的方式定义`F(0)`和`F(1)`，
我们将得不到任何的数字，因为当函数到达为0的时候，将会去计算负数。如果这些发生，你可能会说` F(-2000)= F(-2001) + F(-2002)`，
但这样程序将无法终止。

在`Haskell`中，`递归`十分重要，不像其它命令式语言中(过程式语言，指令按顺逐一执行)，通过递归，你在计算时，只需要定义如何
去做，而不需要如何才能得到这些数据。这也是为什么在`Haskell`中没有`while`语句和`for`语句，因为你可以使用`递归`的思想去实现
它们。

## 最大数

`maximum`方法从一个可以排序的列表(是`Ord`类型类的实例)中，返回其中最大的一个。想像一下，你如何在交互式的操作下实现这一功
能。你可能会选择目前为止最大的数与其余的值逐个去比较，如果比当前最大值还要大，则将这个值做为目前最大值。一直按这个逻辑持
续到列表的最后的那个当前最大值就是列表中的最大值。哈，一个简单地算法却使用了这么多的语言...

现在让我们学习如何使用递归去定义它。(ps:#1)。首先我们设置边界条件，我们说如果列表中只有一个元素，则这个元素就是我们所需求
得的最大值。然后如果表头元素比表尾列表中的最大值还要大，则称这个表头元素为最大值。如果表尾元素中的最大值更大些，则认定该
值为最大值。没错，就只有这些。现在让我们用`Haskell`实现之。

(ps.#1 首先需要理解列表头和尾的概念，列表的第一个元素称为`表头`，除了第一个元素的其余元素组成的列表称为`表尾`，`表尾`是一
个列表，没元素，表示为`[]`)

```haskell
maximum' :: (Ord a) => [a] -> a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs)   
    | x > maxTail = x  
    | otherwise = maxTail  
    where maxTail = maximum' xs 
```

正如你所见，在递归中，模式匹配运行得非常好。绝大多数没有模式匹配的命令式语言就需要一大堆的`if`、`while`语句作为其终止条
件。这里，我们以模式的方式，简单地作些解释。第一个边界条件`maximum' [] = error "maximum of empty list" `，如果列表为空，则
提示当中的语句。因为我们不知道在空的列表中，什么值会是最大的#_#!。第二个模式还是给出了一个边界条件，如果在列表只有一个元
素，则返回这个唯一元素即可。

第三个条件是操作发时需要满足的条件。我们使用模式匹配将一个列表分割成表头和表尾。在列表上应用递归时，这是一个常用的技巧，
去学习使用它吧。我们使用一个`where`绑定去定义一个变量`maxTail`作为表尾元素中最大的元素，然后我们检查表头元素是否大于这个
变量，如果是返回表头元素，如果不是返回该变量。

现在我们使用一个示例`[2,5,1]`，验证是否解出最大值。如果我们调用`maximum`，前两个模式不能成功匹配，第三个模式会将列表分割
成`2`和`[5,1]`，`where`从句想要知道`[5,1]`中哪个是最大值。按照这个逻辑，它再一次匹配到第三个模式，并将`[5,1]`分割成`5`和
`[1]`，且`where`从句想要知道`[1]`中的最大值。因为这个一个边界条件，它会返回`1`。然后向上执行，比较`5`和`[1]`中的最大值(也
就是`1`)，很显然，我们得到`5`为最大值。现在我们已经知道`[5,1]`中的最大值为`5`，再次比较`2`和`[5,1]`中的最大值(也就是`5`)，
还是选择`5`作为最大值。

另外可以用`max`方法，更清晰的方法去实现这个功能。记住，`max`是比较两个数字，返回较大的一个。现在使用`max`去重写`maximum`。

```haskell
maximum' :: (Ord a) => [a] -> a  
maximum' [] = error "maximum of empty list"  
maximum' [x] = x  
maximum' (x:xs) = max x (maximum' xs)  
```

这是多么的优雅！其本质在于，列表的第一个元素和其表尾元素中的最大值的较大都即为该列表的最大值。

## 更多的递归函数

现在，我们知道如何去递归地思考问题。那让我们使用递归去实现一些方法。如`replicate`，`replicate`使用一个`Int`类型的值`n`，
和另一个元素`e`，返回一个包含`n`个`e`的列表。比如，`replicate 3 5`返回`[5,5,5]`。思考一下边界条件。我们的想法是作为边界
条件，那`n`的值为`0`或者更小。如果重复一个元素`0`次，它返回一个空的列表。而对于负数，它其实并没有起到任何作用。

```haskell
replicate' :: (Num i, Ord i) => i -> a -> [a]  
replicate' n x  
    | n <= 0    = []  
    | otherwise = x:replicate' (n-1) x  
```

因为要测试一个`boolean`的条件，这里我们使用`|`来代替模式匹配。如果`n`等于`0`或者小于`0`，返回一个空的列表。否则返回一个
第一个元素为`x`为表头，`n-1`个元素为`x`的表尾，显然，`n-1`的代码又会执行到这个方法，直到到达边界条件。

接下来，我们将实现`take`。该方法用于从元素列表中选取待定个数的元素，并组成列表。比如，`take 3 [5,4,3,2,1]`，会返回`[5,4,3]`。
如果我们从`0`个或更少的列表中选取，则会返回一个空的列表。另外，如果我们从一个空的列表中选择，依然会得到一个空的列表。注意，
这两个边界条件都是必要且正确的。那将它写出来吧。

```haskell
take' :: (Num i, Ord i) => i -> [a] -> [a]  
take' n _  
    | n <= 0   = []  
take' _ []     = []  
take' n (x:xs) = x : take' (n-1) xs  
```

第一个模式说明了，如果我们取`0`个或者负数个元素，将返回一个空的列表。注意，因为我们不需要去关心传进行的参数是什么，所以
我们使用`_`去匹配一个列表。也要注意，我们使用`|`且没有使用`otherwise`从句。也就是当`n`大于0时，会顺着逻辑进行下一个模式中。
第二个说明如果从一个空列表中取，返回一个空列表。第三个模式将列表分割成表头和表尾，然后取`n`个元素的列表，相当于从取一个表
头元素和`n-1`个表尾中的元素组成的列表。请拿出一张纸，思考下使用`take 3 [4,3,2,1]`的执行逻辑。


`reverse`就是将一个列表反转。想像一下边界条件。是什么？动起来想哦(#_#!)。没错，就是空列表。空的列表反转就是自己，还是一个
空的列表。那其余的那些列表呢？那你可以会想到将一个列表分割成表头和表尾。反转相当于将表尾再一次反转，将表头作为列表的最后
一个元素。

```haskell
reverse' :: [a] -> [a]  
reverse' [] = []  
reverse' (x:xs) = reverse' xs ++ [x]
```

^_^，没错，就是这样。


因为`Haskell`支持定义无限循环的列表，那这个递归中的边界条件没有真正地达到这个条件。对于无限列表，没如果真没达到边界条件，
那程序将无限循环地执行，产生无限的输出。那更好的办法就是从无限列表中去切割我们所需要的部分。递归地使用`repeat`可以返回一
个无限列表，使用递归去说明，确实很简单。

```haskell
repeat' :: a -> [a]  
repeat' x = x:repeat' x
```
调用`repeat 3`将会返回以`3`为开头，和以无数个`3`组成的表尾的无限列表。所以调用`repeat 3`相当于`3:repeat 3`、`3:(3:repeat 3)`等等。
`repeat 3`会一直计算，那使用`take 5 (repeat 3)`会返回一个包含5个`3`的列表。事实上，它的就相当于`replicate 5 3`。
