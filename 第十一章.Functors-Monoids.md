# Functors，Applicative和Monoids

`Haskell`是一个大集合，包含高阶函数，侧重算法的参数类型及类型类，对比其它语言，能让我们
在更高的角度去理解并实现`[polymorphism](https://zh.wikipedia.org/wiki/%E5%A4%9A%E5%9E%8B_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6))`。
我们不需要去思考某些类型是否属于某个庞大体系一个类型，相反，我们只要思考类型要做什么，并且
如何使用类型将它们结合在一起。`Int`类型看起来能做很多的事情，可以用于计算，可以用于排序、
或者可以用于枚举，等等。

类型类是对外开放的，我们可以自己定义自己的数据类型，思考该数据类型需要做什么及如何通过类
型类定义一些行为。正因为`Haskell`有强大的类型系统，可以让我们通过函数的类型定义知道关于
函数的一些信息，我们可以自己定义类型，定义一些非常通用、抽象的行为。我们已经看到过一些类
型类的操作，如判断是否相等、通过排序进行比较等。这些都是十分抽象且优雅的行为，但我们并不
认识这些知识点非常特别，因为其实我们在现实生活中，就一直处理这样的事情。最近一个知识点是
`functors`，它最基本的行为就是可以被`map`。`functors`是一个非常有用的例子，并且也很好
地描述了类型类中一些非常抽象的属性。在这个章节中，通过使用更健壮且更有效的`functors`(`applicative functors`)，
我们将近距离的使用、理解`functors`。其中我们也会提到`monoids`，

## Functors 终级版

在前面章节的小单元中，我们已经讨论过`functors`。如果你没有阅读过，有空的时候你应该去看一看。
这里的话，我就假装认为你已经阅读过了#。

先来简单的复习一下，`Functor`是一类可以被`map`的类型，比如`列表`、`树型结构`等等。在`Haskell`
中，这一类型被统一定义成`Functor`类型，它只有一个类型类方法`fmap`，该方法的类型定义为
`fmap :: (a -> b) -> f a -> f b`。其类型定义说明，给我一个函数，这个函数会使用`a`并返回
`b`，或者这个`a`属于某个盒子，返回一个含有`b`的盒子。

> 建议：当你多次看到拿`盒子`来类比，主要是为什么说明`functor`是如何工作的，再后面的内容
中，我们也会使用这个类比来描述`applicative functors`和`monads`，最开始拿`盒子`做类比
可以帮助你理解`functor`，不需要去过分解读。因为有一些`functor`如果还是拿这个类比来说，就
有些牵强。一个更加正确的术语应该是`computational context`。上下文可以是一个计算的对象，
也可能是包含多个元素的列表等其它表达式。

如果你要创建一个`functor`的实例，可以使用`* -> *`，至少需要一实际类型作为类型参数。
