# 高阶函数

> `Haskell`的函数可以使用函数作为参数，并且将函数作为返回值。执行这种操作的函数称为**高
阶函数**。高阶函数并不只有`Haskell`有，其它语言也有，但在`Haskell`中使用高阶函数更加美
妙。其它语言可能需要你定义一步步操作去修改不同变量的值，或者使用循环语句去执行一些操作，
在`Haskell`中，你只需要定义你的原始数据是什么就能帮你完成计算。高阶函数对于任何语言都是
必不可少的，它对于解决问题和思考程序设计是强有力的工具。

## 柯里化函数 [Curried functions](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)

在正式定义中，`Haskell`的函数都只使用一个参数的形式。你可能会想，这怎么可能，到目前为止，
我们已经使用过了好多函数都是使用了多个参数的形式。好吧，这是一个很聪明的小技法。目前我们
所使用到的，看似使用多个参数的函数其实都是柯里化函数。那到底是什么意思？我们通过一个案例
去理解。下面请出我们的好朋友：`max`方法。`max`方法好像使用两个参数并返回其中一个较大者。
在执行`max 4 5`的过程中，首先选择一个参数，如`max 4`，返回结果为一个函数，然后再拿`5`作
为其参数，最后返回我们需要的较大者。这个看起来很怪，但确实是一个不错的想法。下面两个调用
方法是等价的。

```haskell
ghci> max 4 5  
5  
ghci> (max 4) 5  
5  
```

使用空格将不同的标识隔开，是比较简单的函数范式。空格符号就你是一个操作符号，并且它具有较
高的优先级。先让我们看下`max`的类型，`max :: (Ord a) => a -> a -> a`，它还可以写成
`max :: (Ord a) => a -> (a -> a)`。可以理解成`max`函数使用一个`a`作为参数，并返回一个
另一个函数，返回的函数使用`a`作为参数，并返回`a`。这就是为什么返回类型和参数之间使用箭头
作为分隔。

那这些对于我们来说，有什么帮助呢？简单来说，如果我们没有太多参数的函数，意味函数执行并没
有过多参数的参与，这一类方法叫做`partially applied 函数`。使用这一类的函数是比较简洁的，
我们将函数传递到其它函数作为参数或者传入数据到这些函数。

给出下面这个例子

```haskell
multThree :: (Num a) => a -> a -> a -> a  
multThree x y z = x * y * z
```
当我们执行`multThree 3 5 9`或`((multThree 3) 5) 9`，会发生什么？首先，因为使用空格分
隔，`3`被应用于函数`multThree`，返回以使用一个参数，且返回值为函数的一个函数。所以`5`接
着被应用于返回的函数中，再一次返回以使用一个参数，且返回值为函数的一个函数，最后与`15`相
乘，返回`135`。记住，上述的函数类型还可以写成`multThree :: (Num a) => a -> (a -> (a -> a))`。
在`->`前的元素是函数要调用的参数，在其后面是返回值。函数的类型说明指出，使用一个`a`作为
参数，返回一个`(Num a) => a -> (a -> a)`类型的函数。再进一步，返回的函数依然是以一个`a`
作为参数，返回一个函数，形如`(Num a) => a -> a`。最后返回的函数，使用一个`a`作为参数，
并返回一个`a`。

```haskell
ghci> let multTwoWithNine = multThree 9  
ghci> multTwoWithNine 2 3  
54  
ghci> let multWithEighteen = multTwoWithNine 2  
ghci> multWithEighteen 10  
180  
```

我们可以很快速地创建一些少量参数的函数，比如我们要创建一个函数，使用一个`a`作为参数，并
与100比较，我们可以这么做：

```haskell
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred x = compare 100 x  
```

如果我们传入`99`进行调用，会返回`GT`。很简单吧，注意，等式两边的`x`是相等的。现在我们来思
考下`compare 100`的返回值是什么。它会返回一个与`100`比较的函数。这不就是我们想要的吗？
可以使用以下代码进行重写：

```haskell
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred = compare 100  
```

因为`compare 100`返回的是函数，则函数的类型定义是一样的。`compare`的类型是
`(Ord a) => a -> (a -> Ordering)`，当你使用参数`100`，返回类型为`(Num a, Ord a) => a -> Ordering`
的函数。这里需要加上的一个类型约束，其中`100`属于`Num`这个类型类。

> 请确保你已经理解了柯里化函数和部分应用是如何工作的，它们确实都非常重要。

以代码段的形式，中缀形式的函数也可以成为部分应用。只要用括号`()`括起来，并将要使用的参数
跟在后面。这会创建一个使用一个参数的函数，这个参数将用于右边表达式中缺失的部分。请看下面
这个函数：

```haskell
divideByTen :: (Floating a) => a -> a  
divideByTen = (/10)
```

调用`divideByTen 200`就相当于做了`200/20`的计算，也等同于`(/10) 200`。下面这个函数用于
检查给定字符是否属于大写字母：

```haskell
isUpperAlphanum :: Char -> Bool  
isUpperAlphanum = (`elem` ['A'..'Z'])  
```

特别要指出当你使用减号`-`时，会存在歧义。当按段定义函数时，`(-4)`将返回一个使用一个值减去
`4`这样计算的函数，然而，但我们更希望把`(-4)`当做一个负数，所以当你希望实现上述的操作时，
请使用`(subtract 4)`。

那如果我们执行`multThree 3 4`,而不进行`let`的变量绑定，或不将其传入其函数，又会怎样？

```haskell
ghci> multThree 3 4  
<interactive>:1:0:  
    No instance for (Show (t -> t))  
      arising from a use of `print' at <interactive>:1:0-12  
    Possible fix: add an instance declaration for (Show (t -> t))  
    In the expression: print it  
    In a 'do' expression: print it  
```

返回的错误提示我们，这个表达式将会返回一个类型为`a -> a`的函数，但不知道如何将其打印输出。
这个方法不是`Show`类型类的实例，所以找不到比较友好的输出来表示这个函数。在`GHCI`下输入
`1 + 1`，首先它会计算`1 + 1 = 2`，然后调用`show`的函数，将`2`以文本的形式进行输出。
文本形式的`2`是字符中的`"2"`，再将其输出。

## 按序使用高阶函数

通常，函数使用函数作为参数，并返回另一个函数。为了举例说明，创建一个函数，该函数以一个函数
作为参数，并且它将全被调用两次。

```haskell
applyTwice :: (a -> a) -> a -> a  
applyTwice f x = f (f x)  
```

首先，我们看下函数的类型定义，在之前的章节中，我们从来没有使用过括号`()`，因为我们都认为
`->`是一个右连接的符号。在这里`()`被赋予了新的含义，表明函数的第一个参数是一个`a -> a`类型
的函数。第二个参数是某种类型的值，并返回值也是这种类型。这里我们需要以柯里化函数的思想去阅读
这个问题，并在脑海中理解。就可以简单的理解，这个有两个参数，返回一个值，然后第一个参数是
`a -> a`类型的函数，返回值为`a`类型的值。这个函数可以是`Int -> Int`或`String -> String`或
其它，但第二个参数的类型必须与之前的表示一样。

> 从现在开始，我们说，那些使用多个参数的函数，实际上都是将其分解成使用一个参数的函数，返回
一个部分应用的函数，直到某一个函数返回确定的值。尽管我们知道其在背后的实际情况，但出于简单
的目的，我们还是说`a -> a -> a`使用两个参数，并返回一个`a`类型的值。

函数的函数体十分简单，只是将`f`作为一个函数，传入`x`进行计算一次，计算后的结果再传入`f`。
看下函数调用的几个实例：

```haskell
ghci> applyTwice (+3) 10  
16  
ghci> applyTwice (++ " HAHA") "HEY"  
"HEY HAHA HAHA"  
ghci> applyTwice ("HAHA " ++) "HEY"  
"HAHA HAHA HEY"  
ghci> applyTwice (multThree 2 2) 9  
144  
ghci> applyTwice (3:) [1]  
[3,3,1]  
```

部分应用的魅力和好处是多么得明显！如果我们的函数需要一个函数作为参数，且这个函数也只需要
一个参数，那么我们就可以传递一个部分应用的函数给它。


现在我们将使用更高阶的编程技巧，去实现在标准库一个十分有用的函数。它叫做"zipWith"。它使
用一个函数和两个列表作为参数，然后将两个列表内连(即各个元素按次序依次相对应)，然后在各个
元素对中调用这个函数。现在让我们来实现它：

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]  
zipWith' _ [] _ = []  
zipWith' _ _ [] = []  
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

让我们看下它的函数类型定义。第一参数是一个函数，这个函数使用两个参数返回另一个数，它们的参数
类型不需要都一样，但它们也可以一样。第二个参数和第三个参数都是列表，返回的结果也是列表，第
一个列表中的元素都是`a`类型，作为传入参数的函数第一个参数是`a`，第二个列表中的元素类型都
是`b`类型，因为传入参数的函数的第二个参数是`b`，返回的列表是`c`的列表。如果传入参数的类型
定义为`a -> b ->c`，同样它的类型也包括`a -> a-> a`，但反过来就不适用了。记住，当你在编写
函数时，特别是一些高阶的函数，如果不确定函数的类型，你可以先省略函数的定义，然后使用`:t`
命令进行查看。

这个函数的功能和普通的`zip`功能差不多相似。它们的边界条件是一样的，不同在于`zipWith`多了
一个函数作为参数，但这个函数并不会去影响边界条件，所以我只是使用了`_`来代替它。最后一个模式
匹配和`zip`也最后一个也十分相似，除了它没有在`(x,y)`这样的操作，而是使用了`f x y`。如果
一个高阶函数够通用，那么它可以用于许多比较困难的问题中。下面是一些是我们的`zipWith`函数与
不同的函数/参数搭配的一些结果：

```haskell
ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]  
[6,8,7,9]  
ghci> zipWith' max [6,3,2,1] [7,3,1,5]  
[7,3,2,5]  
ghci> zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]  
["foo fighters","bar hoppers","baz aldrin"]  
ghci> zipWith' (*) (replicate 5 2) [1..]  
[2,4,6,8,10]  
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
[[3,4,6],[9,20,30],[10,12,12]]  
```

如你所见，一个高阶函数可以用于不同的场景下。而通常在命令式语言中是做一些`for`循环、`while`
循环、设置中间变量的形式去实现，然后将这个实现方式进行封装，这就是命令式语言中的函数。函
数式编程使用高阶函数，把具体的模式进行抽象，如果测试两列表的对值、在对值上做一些操作、返
回特定的集合或去除一需要的元素(ps: 更多的是理解问题上的方式，而不于说如何去关心具体的操
作)。

现在来来实现另一个标准库的函数`flip`，它使用一个函数作为参数，并返回像我们原始函数的一个
函数，且将传入的参数位置互换。下面看我们如何去实现：

```haskell
flip' :: (a -> b -> c) -> (b -> a -> c)  
flip' f = g  
    where g x y = f y x  
```

仔细看下这个函数类型定义，我们说这方法是使用`a`和`b`作为参数，返回一个使用`b`和`a`的函数
(ps:重点就在于参数的位置顺序)。由于函数都是柯里化的函数，因为`->`就是表示右连的，所以第二
对括号不是必需的。`(a -> b -> c) -> (b -> a -> c)`和`(a -> b -> c) -> (b -> (a -> c))`
是一样的，也和`(a -> b -> c) -> b -> a -> c`一样。我们有写`g x y = f y x`，如果是`true`，
那么`f y x = g x y`是不是也应该有效。记住这一点，我们可以更简单的组织方式进行定义：

```haskell
flip' :: (a -> b -> c) -> b -> a -> c  
flip' f y x = f x y  
```

鉴于函数都是柯里化的，当我们不带`x`和`y`调用`filp' f`，时，它会返回一交换两个参数顺序的结果。尽管类似这样的函数经常被当作参数传递给其它函数，通过事先考虑并写下要返回的结果，便可更好地
利用柯里化函数的优势。

```haskell
ghci> flip' zip [1,2,3,4,5] "hello"  
[('h',1),('e',2),('l',3),('l',4),('o',5)]  
ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]  
[5,4,3,2,1]  
```

## Maps和filters

`map`使用一个参数函数和一个列表，列表中的每一个元素都被去调用参数函数，返回一个新的列表。
让我们看下它的声明和定义：

```haskell
map :: (a -> b) -> [a] -> [b]  
map _ [] = []  
map f (x:xs) = f x : map f xs
```

其类型声明表示,这个函数使用一个使用`a`返回`b`的函数作为参数，并使用一个`a`的列表作为参数，
最后返回一个`b`的列表。通过查看函数的类型声明，就十分有趣，你可能就已经知道它具体是做什么
的了。`map`是从多种高阶函数之一，可以用在许多不同的地方：

```haskell
ghci> map (+3) [1,5,3,1,6]  
[4,8,6,4,9]  
ghci> map (++ "!") ["BIFF", "BANG", "POW"]  
["BIFF!","BANG!","POW!"]  
ghci> map (replicate 3) [3..6]  
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  
ghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]  
[[1,4],[9,16,25,36],[49,64]]  
ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[1,3,6,2,2]  
```

你可以能发现了，上面这些都可以通过列表表达式去实现。`map (+3) [1,5,3,1,6]`和`[x+3 | x <- [1,5,3,1,6]]`
是一样的。然而，当一个函数作为参数时，使用`map`函数更具有可读性。特别你在处理嵌套的`map`时，
那么多的方法括号`[]`看着也很乱。

`filter`函数是一个使用一个断言(断言是一个函数，告诉你什么情况下是`true`或什么时候是`false`)，
和一个列表，用列表中的每一个元素去测试这个断言。它的类型声明和实现如下：

```haskell
filter :: (a -> Bool) -> [a] -> [a]  
filter _ [] = []  
filter p (x:xs)   
    | p x       = x : filter p xs  
    | otherwise = filter p xs  
```

十分简单的例子！如果`p x`执行返回`True`，这个元素将包含在新的列表中，如果不是，则这个元素
将普查排除。一些使用的例子如下：

```haskell
ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]  
[5,6,4]  
ghci> filter (==3) [1,2,3,4,5]  
[3]  
ghci> filter even [1..10]  
[2,4,6,8,10]  
ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]  
[[1,2,3],[3,4,5],[2,2]]  
ghci> filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"  
"uagameasadifeent"  
ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"  
"GAYBALLS"  
```

上面的所有功能都可以使用列表推导式实现。没有任何规定说，什么时候用`filter`实现，什么时候
用列表推导式实现。你只要根据可读性选择使用即可。使用`filter`时和使用列表推导式一样可以使用
逻辑运算符`&&`来连接多个断言。

还记得上一章节中讲的`快速排序`的例子吗？我们使用列表推导式过滤出小于中间值或大于等于中间值
的列表。使用`filter`，代码可读性强，可实现相同的功能。

```haskell
quicksort :: (Ord a) => [a] -> [a]    
quicksort [] = []    
quicksort (x:xs) =     
    let smallerSorted = quicksort (filter (<=x) xs)  
        biggerSorted = quicksort (filter (>x) xs)   
    in  smallerSorted ++ [x] ++ biggerSorted  
```

`map`和`filter`是所有函数式编程语言中必有的东西。使用`map`、`filter`或使用列表推导式都
是没有任何问题的，只要能实现功能就可以。回忆下之前我们是如何在一个中心的周围找到合适的三角
形的。在命令式(过程式)的语言中，我们可以使用三个嵌套的一循环语句然后测试当前的组合是否满足
要找的三角形的条件。如果条件满足，则将其打印。在函数式编程中，这个逻辑就可以使用`mapping`和
`filtering`来实现。你只要创建一个使用一个参数并返回一些结果的函数，这个函数会遍历列表中所有
值，然后通过`filter`过滤出满足我们要求的结果。正是由于`Haskell`中的惰性求值，让我们在多次
在同一个列表中调用`filter`和`map`时，过列表中的元素只需要一次。

现在让我们找一下小于`100000`且能被`3829`整除的最大的数，为了实现这个，我们需要将所有可能的数
检查一次，下面是我们的解决方案：

```haskell
largestDivisible :: (Integral a) => a  
largestDivisible = head (filter p [100000,99999..])  
    where p x = x `mod` 3829 == 0  
```

首先我们要先创建一个按降序排列、小于`100000`所有数的列表，然后去通过我们的声明的断言去
过滤，正因为所有的数都是已经按降序排列的，当最大的那个满足我们断言的那个元素返回`True`时，
后面的元素将不会被执行断言的判定。惰性求值在这里又发挥了重大的作用。因为我们只是需要所满足
数列表中的第一个，不需要去关心列表是有限的还是无穷的。程序会停止，如果第一个满足要求已经被
找到。

下面，我们将要求所有平方小于`10000`,且为奇数的和。但是首先，在这个解决方案中，我们将先介绍
下`takeWhile`函数。这个函数使用一个断言和一个列表作为参数，从列表的第一个参数开始到列表结束
去测试这个断言，一旦有一个元素不符合断言就不再继续执行。如果我们要找出字符串`"elephants know how to party"`
中的每一个单词，可以使用`takeWhile (/=' ') "elephants know how to party`，然后它会返
回`elephants`。好吧。现在说下如何对所有平方为奇数且小于`10000`的数进行求和。首先使用`(^2)`去`map`一个无穷列表`[1..]`，然后过滤出只有奇数的列表，再通过`takeWhile`选择小于`10000`
的值，最后使用`sum`进行求和。我们不需要定义一个函数，在`GHCI`中可以很快实现。

```haskell
ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))  
166650  
```

是不是很神奇。我们使用一些原始数据(自然数的无穷序列)，然后`map`之、`filter`之，再将其截
断取符合我们需要的，再将它们求和。当然我们也可以使用列表推导式：

```haskell
ghci> sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])  
166650  
```

你觉得哪一个简单，那就是你个偏好的问题啦。再强调一次，`Haskell`中的隋性求值让我们能够`map`
和`filter`一个无限列表，这是因为它不会马上就行`map`和`filter`。正由于它的这些执行操作，
只有我们需要`Haskell`返回由`takeWhile`出来列表的和时，`takeWhile`都会去`filter`和`map`
数据，直到有一个数大于等于`10000`就会停止。

好，下一个问题我们来处理这么一个序列。我们使用一个自然数，如果这个自然是偶数就将它除以`2`，
如果这个自然数是奇数就将它乘以`3`再加`1`。相同的逻辑也同样应用于上一个的返回结果中，并产
生一个新的数。事实上，我们得到了一串数值信息。对于所有最初的值，这串值的最后一个值为`1`。
所以当我们使用一个数值`13`，我们会得到序列：`13, 40, 20, 10, 5, 16, 8, 4, 2, 1`。`13*3 + 1`
等于`40`，`40`除以`2`等于`20`，这样一直下去，如此之后，有`10`个这样的操作周期。

现在我们想知道：从`1`到`100`中，有多少个数与上述相同的周期有几个？首先，我们先看看定义这么
一个函数并调用一下：

```haskell
chain :: (Integral a) => a -> [a]  
chain 1 = [1]  
chain n  
    | even n =  n:chain (n `div` 2)  
    | odd n  =  n:chain (n*3 + 1)  
```

最后一个值为`1`，显然就是递归的边界条件。这是一个标准的递归函数。

```haskell
ghci> chain 10  
[10,5,16,8,4,2,1]  
ghci> chain 1  
[1]  
ghci> chain 30  
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
```

看起来工作非常正常。现在，下面一个函数将告诉我们上一个问题的答案：

```haskell
numLongChains :: Int  
numLongChains = length (filter isLong (map chain [1..100]))  
    where isLong xs = length xs > 15  
```

我们使用`map`函数对`[1..100]`是每个元素进行`chain`操作，每一次`chain`操作都返回一个列表，
然后过滤出其中长度大于`15`的，执行完一次`filter`后，我们就知道结果列表中有多个长度大于`15`
的列表。

> 注意：在这个函数中使用`numLongChains :: Int`是因为`length`返回的是`Int`类型，而不是
`Num`类型，这当然有它的历史原因。如果你想得到更为普通的数，可以使用`fromIntegral`被应用
于返回的结果上。

我们当然也可以这样使用`map`，`map (*) [0..]`,它可以很好的展示柯里化函数是如何工作的及分部
应用函数确确实实是数值类型(你只是不能将它们转换成字符串)。目前为止，我们所传递给`map`的函数
都只是拿列表中的一个元素作为参数，比如`map (*2) [0..]`,其类型声明可表示为`(Num a) => [a]`。
但是我们也可以使用`map (*) [0..]`，这个完全没有任何问题。那这里又会发生什么呢？原因在于
列表中的一个元素应用于`*`函数，而这个函数的类型是`(Num a) => a -> a -> a`，使用一个类型为
`a`作为参数，返回一个另一个函数，这个函数也是只有一个参数并返回值类型为`a`。如果我们在列表
`[0..]`上`map`使用`*`，则我们将得到一个元素类型为函数的列表，其中的函数都使用一个参数，
返回类型如`(Num a) => [a -> a]`。`map (*) [0..]`返回一个列表，如果写出的话就应该是
`[(0*),(1*),(2*),(3*),(4*),(5*)...`。

```haskell
ghci> let listOfFuns = map (*) [0..]  
ghci> (listOfFuns !! 4) 5  
20  
```

取得下标为`4`的元素，它是一个函数，相当于`(4*)`，然后我们将`5`作为参数传入。执行的过程
就如`(4*) 5`或`4 * 5`。

## Lambdas

`Lambda`表达式是基本的匿名函数，特别在我们只使用函数一次的情况下常常会用到。一般情况下，
我们将创造的`Lambda`表达式传入到一个高阶函数。要编写`Lambda`表达式，你要先写一个`\`，
然后写出它的参数，使用空格分隔，再其后紧跟`->`，再写函数体。通常我们都需要使用括号`()`将
它们括起来。不然，`Lambda`表达式会一直向右延伸开来。

之前我们有在`numLongChains`函数中使用`where`绑定去定义一个`isLong`的函数，这个函数的作为
在于如何去过滤元素。现在我们使用`Lambda`表达式进行重写：

```haskell
numLongChains :: Int  
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))
```

`Lambda`表达式，人如其名，它就是一个表达式。这就是为什么我们可以将它在这里使用。表达式
`(\xs -> length xs > 15)`返回一个函数，用于测试一个列表的长度是否大于`15`。


一些对柯里化函数和分部应用不怎么熟悉的小伙伴经常会在不需要`Lambda`表达式中的地方使用
`Lambda`表达式。比如`map (+3) [1,6,3,2]`和`map (\x -> x + 3) [1,6,3,2]`是等价的，
`(+3)`和`(\x -> x + 3)`的作用都将一个数加`3`。不得不说，在这个地方使用`Lambda`表达式
是一种`stupid`的方法，因为使用分部应用更具有可读性。

和其它的函数一样，`Lambda`表达式也可以使用多个参数

```haskell
ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]  
[153.0,61.5,31.0,15.75,6.6]  
```

也和其它函数一样，你可以在`Lambda`表达式中使用模式匹配。唯一的不同的地方再于，你不能定义
对单一的一个参数进行模式匹配。就好像你使用`[]`和`(x:xs)`去匹配是一样的。如果在`Lambda`
表达式中匹配失败，会报运行时错误，所以在`Lambda`表达式中使用模式匹配一定要小心。

```haskell
ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[3,8,9,8,7]  
```

`Lambda`表达式通常使用括号括起来，除非我们就是想让这个表达式一直向右延伸。这里有一些有趣
的东西。正是由于函数都是柯里化函数，下面两个是等价的：

```haskell
addThree :: (Num a) => a -> a -> a -> a  
addThree x y z = x + y + z  
```

```haskell
addThree :: (Num a) => a -> a -> a -> a  
addThree = \x -> \y -> \z -> x + y + z
```

如果我们这样定义函数，可以很明显看出函数的类型定义。这里有三个`->`，都是用于类型定义的。
当然第一种方法的可读性更高点，第二种更像是举例说明柯里化函数的小花招。

然而，在一些其它的场景下，使用这种标记法显得很棒。如果我想让`flip`函数再可读性高点，我们
可以定义：

```haskell
flip' :: (a -> b -> c) -> b -> a -> c  
flip' f = \x y -> f y x  
```

尽管这样的写法与`flip' f x y = f y x`是一样的。但在大多数的情况下，能让我们很明显地意识
到，这么做可以返回一个新函数。

## Only folds and horses

之前我们在使用处理递归时，我们发现了在列表上使用递归一种通用的模式，那就是把空列表当作是
边界条件。我们引入`x:xs`这种模式，将一个列表分成第一个单个元素和其余元素。这是一种非常通
用的模式，所以现在将介绍两个函数对这种模式进行封装。这些函数叫做`折叠`，和`map`函数是同
一种类型的，但只会返回结果列表的某些值。

一个`折叠`函数使用一个函数，个初始值(可以叫做累加器)和一个列表。其中，函数使用两个参数，
一个是那个累加器值，还有一个是列表的第一个(或最后一个)，返回一个新的累加器值。然后这个
函数两次被调用，将之前的累加器值与新列表的中的第一个(最后一个)，诸如此类。当将所有的列表
值遍历完后，只留下了累加器的值，正是我们要的生成的值。

首先我们看下`foldl`函数，也叫做`左折叠`，从左至右进行运算。参数函数使用初始值和列表的头
元素，产生一个新的累加器值，然后再将这个值与列表的头元素再次进行运算。

让我们再一次实现`sum`函数，这一次，我们使用`fold`代替显式的递归。

```haskell
sum' :: (Num a) => [a] -> a  
sum' xs = foldl (\acc x -> acc + x) 0 xs  
```

测试一下吧：

```haskell
ghci> sum' [3,5,2,1]  
11  
```

让我们深入地去了解下`fold`发生了什么。`\acc x -> acc + x`就是那个参数函数，`0`是初始值，
而`xs`就是需要被折叠的列表。首先，参数`acc`赋值为`0`，`x`赋值为`3`，`0+3`返回`3`，它成
为新的增加值。接下来，`3`被当做累加器的值，`5`被赋值给`x`，就生成了新的累加器值`8`。按照
这个逻辑来，`8`是这个累加器值，`2`变成了当前的`x`的值，新的累加器值为`10`。最后`10`再和
`1`进行运算，生成`11`。恭喜你哈，你完成了一次折叠操作。


<div align="center">

![](/images/chapter06/foldl.png)

</div>

上图使用下个图例一步一步展示了一个折叠操作到底发生了什么。带点绿色的值为累加器的值，你可
以看到消费的过程是从左边开始。如果我们考虑到函数都是柯里化的，可以将函数写得更简洁，比如：

```haskell
sum' :: (Num a) => [a] -> a  
sum' = foldl (+) 0  
```

之前的`Lambda`表达式`(\acc x -> acc + x)`和`(+)`是一样的。我们可以忽略`xs`作为参数，这
是因为调用`foldl (+) 0`将返回一个使用列表的函数。通常，如果你有一个函数，形如：`foo a = bar b a`，
你可以使用`foo = bar b`，正是利用的了柯里化函数的特点。

在介绍从右折叠操作之前，我们再来实现另一个函数。我确信你们都是知道`elem`函数的，
它是用于检测一个元素是否在一个列表中。下面是我们的实现:

```haskell
elem' :: (Eq a) => a -> [a] -> Bool  
elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys  
```

好吧，我们在这里能发现什么？初始累加器的值是一个布尔类型的值。初始累加器的类型通常和返回
值的类型是一样的。记住，如果你不知道用什么作为初始值，这样思考可能会给你一些思路。首先，
我们从`False`开始，将`False`作为初始值。我们首先假设这个值不存在列表中，当然，当我们在
一个空的列表使用一个折叠函数，返回值的结果就只能是那个初始值。然后检查当前的元素是否是要
查找的那个。如果是，那么累加器赋值为`True`，如果不是，我们让累加器保持不变。如果它之前是
`False`，说明当前的值不是要找的值，如果是`True`，我们离开它。

右折叠`foldr`的工作模式和左折叠`foldl`一样，只是累加器到算的时候从右边开始。左折叠和右折
叠一样，都是先拿累加器的初始值作为每一个参数，并将列表中的当前值作为第二个参数。不同的地方
在于，右折叠是从右边开始。

累加器值的类型(当然也是返回结果的类型)可以是任何类型。它可以是一个数字、一个布尔类型、甚至
是一个新的列表。我会使用右折叠还实现`map`函数。这个累加器会是一个列表，会依次在列表中的每
个元素进行`map`操作。那当然，初始值肯定是一个空的列表`[]`。

```haskell
map' :: (a -> b) -> [a] -> [b]  
map' f xs = foldr (\x acc -> f x : acc) [] xs
```

如果我们将`(+3)`操作应用于`[1,2,3]`，我们的操作方向是从右到左。首先我们使用最后一个元素
`3`，函数将使用`3`作为参数，结束后返回`6`。将返回值`6`进行前置于累加器`[]`。`6:[]`就是
`[6]`，而且现在就是我们累加器的值为`[6]`。再将`(+3)`应用于`2`，返回值`5`将前置于`[6]`,
现在我们累加器的值为`[5,6]`。最后将`(+3)`应用于`1`，返回值前置于累加器，则得到最终的值
`[4,5,6]`。

当然，我们也可以使用`右折叠foldl`来实现上述的功能，代码如:`map' f xs = foldl (\acc x -> acc ++ [f x]) [] xs`。
其中有一点需要注意，代码中使用`++`的性能消耗比`:`大，所以通常情况下，**我们从一个旧的列表中
生成一个新的列表，使用的右折叠。**

如果你要反转一个列表，使用左折叠还是右折叠都是可以实现的。有时候你甚至不必做这些。使用`foldl`
和`foldr`去实现`sum`是完全一样的。唯一的不同在于，`foldr`在可以在无穷列表中使用，而`foldl`
则不行。为了说清楚这些，如果你有一个无穷列表，需要从右点开始折叠进行操作，最后你肯定要到达
列表的第一个元素。但如果你使用一个无穷列表，从左开始进行折叠操作，你将永远到达不到右边结束的
位置。

如果你只一次访问一个列表，那`折叠函数`就可以实现需要的任何功能，元素被一个个访问，然后根
据这些元素返回相应结果。无论何时，只要你想访问一个列表并返回一个结果，`折叠`就是你可选择
的方法。这就是为什么`折叠函数foldl、foldr`和`map，filter`一样，在函数式编程中是最为有用
的方法之一。

`foldl1`和`foldr1`，这两个函数与`foldl`和`foldr`是如此的相似，不同的地方在于你不需要显
式的提供一个初始值。它们假设列表中的第一个值(或最后一个值)作为初始值，然后将第二个元素与之
进行运算。请注意到这一点，`sum`函数是完全可以用`sum = fold1 (+)`来实现的。因为列表至少需
要一个元素，如果传入空列表将会报错。而另一方面，`fold1`和`foldr`就可以使用空列表作参数。
当你想要使用`折叠`时，请优先考虑空列表的情况。如果函数逻辑中，空列表如果是不合理的参数，
你可以选择使用`foldl1`和`foldr1`来实现。

下面来展示下`折叠`函数的强大~我们将使用`fold`来实现很多的标准库函数。

```haskell
maximum' :: (Ord a) => [a] -> a  
maximum' = foldr1 (\x acc -> if x > acc then x else acc)  

reverse' :: [a] -> [a]  
reverse' = foldl (\acc x -> x : acc) []  

product' :: (Num a) => [a] -> a  
product' = foldr1 (*)  

filter' :: (a -> Bool) -> [a] -> [a]  
filter' p = foldr (\x acc -> if p x then x : acc else acc) []  

head' :: [a] -> a  
head' = foldr1 (\x _ -> x)  

last' :: [a] -> a  
last' = foldl1 (\_ x -> x)  
```

`head`最好的办法当然是使用模式匹配来实现，在这里展示，只是为说明`fold`也可以实现`head`。
我们的`reverse'`的定义十分简单。它的初始值为`[]`，然后从左到右将元素前置到累加器列表。
最后，我们生成了一个反序的列表。`\acc x -> x : acc`这类函数看起来像是`:`的函数，只是两
个参数交换了位置。这就是为什么我们可以使用`foldl (flip (:)) []`来达到将列表反序的目的。


还有一种描述右折叠的方式：我们有一个右折叠函数和一个参数函数，初始值为`z`。如果在`[3,4,5,6]`
上执行右折叠，本质上我们做的操作是`f 3 (f 4 (f 5 (f 6 z)))`。列表的最后一个参数和初始值
被参数函数作为参数，返回的值作为下一次调用的参数。如果我们`f`操作为`+`，初始值为`0`，那就是
`3 + (4 + (5 + (6 + 0)))`。或者也可以使用`+`作为前缀函数的形式`(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))`,
也是一样的。在列表上执行左折叠，此时的参数函数为`g`，`z`作为初始值，相当于执行了
`g (g (g (g z 3) 4) 5) 6`。如果我们使用`flip (:)`作为参数函数，空列表`[]`作为初始值
(相当于我们反转了列表)，就等于执行了`flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6`，
可以保证，如果你执行了上述的表达式，你将会得到`[6,5,4,3]`。

`scanl`和`scanr`与`foldl`和`foldr`相似，不同的地方在于，每个累加器的状态值都会保留在返回
的列表中。它也会左右两种方向的操作，和`foldl`和`foldr`相似。

```haskell
ghci> scanl (+) 0 [3,5,2,1]  
[0,3,8,10,11]  
ghci> scanr (+) 0 [3,5,2,1]  
[11,8,3,1,0]  
ghci> scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1]  
[3,4,5,5,7,9,9,9]  
ghci> scanl (flip (:)) [] [3,2,1]  
[[],[3],[2,3],[1,2,3]]  
```

如果你使用了`scanl`，最后累加器的结果会在返回列表中的最后一个，如果你使用了`scanr`的话，
累加器的结果会在返回列表中的第一个。

`扫描scan`可以用来监控由函数的执行状态。让我们来回答这个问题：一个和式中多个元素相加后会
大于`1000`。为了得到所有自然数的平方根，我们使用`map sqrt [1..]`。现在我们要得到这个和，
我们可以做一个折叠操作，但我们只关心在求和过程上的执行状态，那么就需要一个扫描函数。一旦
做了扫描的操作，我们就知道多少个和式是小于`1000`的了。扫描列表中的第一个元素为`1`,很显然
第二个元素为`1 + 2的平方根`，第三个会是`第二个元素 + 3的平方根`。如果有`X`个的和式是小于
`1000`，那么`X+1`个元素相加就会大于`1000`。

```haskell
sqrtSums :: Int  
sqrtSums = length (takeWhile (<1000) (scanl1 (+) (map sqrt [1..]))) + 1
```

```haskell
ghci> sqrtSums  
131  
ghci> sum (map sqrt [1..131])  
1005.0942035344083  
ghci> sum (map sqrt [1..130])  
993.6486803921487  
```

这里我们使用`takeWhile`来代替`filter`，因为`filter`不能在无限列表中上使用。尽管我们知道
这个列表是升序的，现在是`filter`不知道。所以我们使用`takeWhile`，在第一次和式的值大
于`1000`处进行切割。

## 使用美元符$

在数学，复合函数的定义可能形如`(f . g)(x) = f(g(x))`，用来表示一个复合两个函数，并产生另一
个函数。当使用`x`作为参数时，`g(x)`的返回值作为`f`的参数。

在`Haskell`中，复合函数是一样的。我们使用`.`函数来创建一个复合函数，定义如下：

```haskell
(.) :: (b -> c) -> (a -> b) -> a -> c  
f . g = \x -> f (g x)  
```

注意到它的类型定义，`f`所使用的参数类型必须要与`g`返回值的类型一样。所以返回后的函数，使用
与`f`相同的参数类型，其返回值类型与`g`的返回值类型相同。表达式`negate . (* 3)`返回一个
函数，使用一个数值作为参数，将其乘以`3`并取负号，返回之。

将复合函数应用于函数参数的传递是它的一个用处之一。当然，我们可以使用`Lambda`表达式，但更多
的时候，使用复合函数会更清晰、更简洁。现在，我们有一个包含数字的列表，现在我们需要将它们转化
各自的负数形式，一种方式是将它们全部转换为正的，再进行取负，就像这样：

```haskell
ghci> map (\x -> negate (abs x)) [5,-3,-6,7,-3,2,-19,24]  
[-5,-3,-6,-7,-3,-2,-19,-24]  
```

请注意，在这里的`Lambda`表达式就和我们要做的复合函数的返回函数是一样的。使用复合函数的形式，
我们可以将代码改写：

```haskell
ghci> map (negate . abs) [5,-3,-6,7,-3,2,-19,24]  
[-5,-3,-6,-7,-3,-2,-19,-24]  
```

太好了。复合函数是右连接的，所以我们可以同时组合多个函数。表达式`f (g (z x))`就相当于
`(f . g . z) x`，注意，我们可以把下面的

```haskell
ghci> map (\xs -> negate (sum (tail xs))) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]
```

转换成

```haskell
ghci> map (negate . sum . tail) [[1..5],[3..6],[1..7]]  
[-14,-15,-27]  
```

但是当函数是使用多个参数时又该怎么办呢？很好，如果我们想要有复合函数中使用多个参数，通常
情况下就需要使用分部应用的方式，这样每一个函数就只会使用到一个参数。`sum (replicate 5 (max 6.7 8.9))`
可以被改写成`(sum . replicate 5 . max 6.7) 8.9`或者`sum . replicate 5 . max 6.7 $ 8.9`。
这里发生了什么？其实就相当于是创建一个函数，这个函数是由`max 6.7`这个分部应用被作为参数
应用于`replicate 5`后返回的函数，再由`sum`进行应用，最后，这个函数使用`8.9`作为它的参数
进行运算。如果你想重写这个函数(这个函数中有两个括号`()`)，可以在内层的函数后加上一个`$`符号，
它们将组成一个整体进行运算，其中最后一个参数不用写且用`.` 进行连接。如果你有一个表达式如
`replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))`，你可以
将它写成`replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]`，
如果一个表达式最后有三个括号，尝试着将它改写成复合函数的形式吧，可想而知，它需要三个复合
操作。

另一种复合函数的定义称为`pointless风格`。我们先写下这个示例：

```haskell
sum' :: (Num a) => [a] -> a     
sum' xs = foldl (+) 0 xs  
```

`xs`在等式两边的最右侧，正因为函数是`柯里化的`，我们可以忽略两边的`xs`。`foldl (+) 0`会
创建一个使用列表的函数。如果我们这样写`sum' = foldl (+) 0`就是`point free`风格。那我们
如何使用这种风格进行编写代码呢？

```haskell
fn x = ceiling (negate (tan (cos (max 50 x))))  
```

如上，在这里我们必须要去使用`x`，这是没有办法避免的。`x`在这个函数体内的，并且在它后面还有
括号。`cos (max 50)`好像也行不通，我们得不到一个比较简洁的函数。那我们能做什么呢？就是用
一个表达式`fn`来表示一个复合函数

```haskell
fn = ceiling . negate . tan . cos . max 50  
```

太棒了，使用用`point free`风格，让代码看着更加可读和简洁。这是一种能让你的思考，函数两两
之间是相互作用的结果，而不是去想像如何将数据当作参数填充进去。你可以使用一些简单的函数，将
它们组合一个复合函数，从而有更多复杂的功能。然而在很多情况下，如果这个函数的功能太复杂了，
使用`point free`风格会使代码可读性变差。所以这里不鼓励创建那种长长的、链条式的复合函数。
尽管十分有用，但在复杂情况下避免使用。比较推荐的方法是使用`let`绑定，将一个大问题拆解成
各个小问题，然后将小问题的解决方案组合成大问题的解决方案，这样的代码形式也让容易让去阅读、
理解。

在`maps`和`filters`章节中，我们解决了如何求奇数和的值(这个值小于`10000`)。现在我们将用
一个方法来解决这个问题：

```haskell
oddSquareSum :: Integer  
oddSquareSum = sum (takeWhile (<10000) (filter odd (map (^2) [1..])))  
```

正因为我们已经接触到了复合函数，我们可能像现在这么写：

```haskell
oddSquareSum :: Integer  
oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]  
```

但于，对于某些来说，阅读这样的代码是比较吃力的，那可以写成如下的形式：

```haskell
oddSquareSum :: Integer  
oddSquareSum =   
    let oddSquares = filter odd $ map (^2) [1..]  
        belowLimit = takeWhile (<10000) oddSquares  
    in  sum belowLimit  
```

这个代码形式是比较差的，但有些人可能会更希望阅读这样的代码。
