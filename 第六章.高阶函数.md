# 高阶函数

> `Haskell`的函数可以使用函数作为参数，并且将函数作为返回值。执行这种操作的函数称为**高
阶函数**。高阶函数并不只有`Haskell`有，其它语言也有，但在`Haskell`中使用高阶函数更加美
妙。其它语言可能需要你定义一步步操作去修改不同变量的值，或者使用循环语句去执行一些操作，
在`Haskell`中，你只需要定义你的原始数据是什么就能帮你完成计算。高阶函数对于任何语言都是
必不可少的，它对于解决问题和思考程序设计是强有力的工具。

## 柯里化函数 [Curried functions](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)

在正式定义中，`Haskell`的函数都只使用一个参数的形式。你可能会想，这怎么可能，到目前为止，
我们已经使用过了好多函数都是使用了多个参数的形式。好吧，这是一个很聪明的小技法。目前我们
所使用到的，看似使用多个参数的函数其实都是柯里化函数。那到底是什么意思？我们通过一个案例
去理解。下面请出我们的好朋友：`max`方法。`max`方法好像使用两个参数并返回其中一个较大者。
在执行`max 4 5`的过程中，首先选择一个参数，如`max 4`，返回结果为一个函数，然后再拿`5`作
为其参数，最后返回我们需要的较大者。这个看起来很怪，但确实是一个不错的想法。下面两个调用
方法是等价的。

```haskell
ghci> max 4 5  
5  
ghci> (max 4) 5  
5  
```

使用空格将不同的标识隔开，是比较简单的函数范式。空格符号就你是一个操作符号，并且它具有较
高的优先级。先让我们看下`max`的类型，`max :: (Ord a) => a -> a -> a`，它还可以写成
`max :: (Ord a) => a -> (a -> a)`。可以理解成`max`函数使用一个`a`作为参数，并返回一个
另一个函数，返回的函数使用`a`作为参数，并返回`a`。这就是为什么返回类型和参数之间使用箭头
作为分隔。

那这些对于我们来说，有什么帮助呢？简单来说，如果我们没有太多参数的函数，意味函数执行并没
有过多参数的参与，这一类方法叫做`partially applied 函数`。使用这一类的函数是比较简洁的，
我们将函数传递到其它函数作为参数或者传入数据到这些函数。

给出下面这个例子

```haskell
multThree :: (Num a) => a -> a -> a -> a  
multThree x y z = x * y * z
```
当我们执行`multThree 3 5 9`或`((multThree 3) 5) 9`，会发生什么？首先，因为使用空格分
隔，`3`被应用于函数`multThree`，返回以使用一个参数，且返回值为函数的一个函数。所以`5`接
着被应用于返回的函数中，再一次返回以使用一个参数，且返回值为函数的一个函数，最后与`15`相
乘，返回`135`。记住，上述的函数类型还可以写成`multThree :: (Num a) => a -> (a -> (a -> a))`。
在`->`前的元素是函数要调用的参数，在其后面是返回值。函数的类型说明指出，使用一个`a`作为
参数，返回一个`(Num a) => a -> (a -> a)`类型的函数。再进一步，返回的函数依然是以一个`a`
作为参数，返回一个函数，形如`(Num a) => a -> a`。最后返回的函数，使用一个`a`作为参数，
并返回一个`a`。

```haskell
ghci> let multTwoWithNine = multThree 9  
ghci> multTwoWithNine 2 3  
54  
ghci> let multWithEighteen = multTwoWithNine 2  
ghci> multWithEighteen 10  
180  
```

我们可以很快速地创建一些少量参数的函数，比如我们要创建一个函数，使用一个`a`作为参数，并
与100比较，我们可以这么做：

```haskell
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred x = compare 100 x  
```

如果我们传入`99`进行调用，会返回`GT`。很简单吧，注意，等式两边的`x`是相等的。现在我们来思
考下`compare 100`的返回值是什么。它会返回一个与`100`比较的函数。这不就是我们想要的吗？
可以使用以下代码进行重写：

```haskell
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred = compare 100  
```

因为`compare 100`返回的是函数，则函数的类型定义是一样的。`compare`的类型是
`(Ord a) => a -> (a -> Ordering)`，当你使用参数`100`，返回类型为`(Num a, Ord a) => a -> Ordering`
的函数。这里需要加上的一个类型约束，其中`100`属于`Num`这个类型类。

> 请确保你已经理解了柯里化函数和部分应用是如何工作的，它们确实都非常重要。

以代码段的形式，中缀形式的函数也可以成为部分应用。只要用括号`()`括起来，并将要使用的参数
跟在后面。这会创建一个使用一个参数的函数，这个参数将用于右边表达式中缺失的部分。请看下面
这个函数：

```haskell
divideByTen :: (Floating a) => a -> a  
divideByTen = (/10)
```

调用`divideByTen 200`就相当于做了`200/20`的计算，也等同于`(/10) 200`。下面这个函数用于
检查给定字符是否属于大写字母：

```haskell
isUpperAlphanum :: Char -> Bool  
isUpperAlphanum = (`elem` ['A'..'Z'])  
```

特别要指出当你使用减号`-`时，会存在歧义。当按段定义函数时，`(-4)`将返回一个使用一个值减去
`4`这样计算的函数，然而，但我们更希望把`(-4)`当做一个负数，所以当你希望实现上述的操作时，
请使用`(subtract 4)`。

那如果我们执行`multThree 3 4`,而不进行`let`的变量绑定，或不将其传入其函数，又会怎样？

```haskell
ghci> multThree 3 4  
<interactive>:1:0:  
    No instance for (Show (t -> t))  
      arising from a use of `print' at <interactive>:1:0-12  
    Possible fix: add an instance declaration for (Show (t -> t))  
    In the expression: print it  
    In a 'do' expression: print it  
```

返回的错误提示我们，这个表达式将会返回一个类型为`a -> a`的函数，但不知道如何将其打印输出。
这个方法不是`Show`类型类的实例，所以找不到比较友好的输出来表示这个函数。在`GHCI`下输入
`1 + 1`，首先它会计算`1 + 1 = 2`，然后调用`show`的函数，将`2`以文本的形式进行输出。
文本形式的`2`是字符中的`"2"`，再将其输出。

## 按序使用高阶函数

通常，函数使用函数作为参数，并返回另一个函数。为了举例说明，创建一个函数，该函数以一个函数
作为参数，并且它将全被调用两次。

```haskell
applyTwice :: (a -> a) -> a -> a  
applyTwice f x = f (f x)  
```

首先，我们看下函数的类型定义，在之前的章节中，我们从来没有使用过括号`()`，因为我们都认为
`->`是一个右连接的符号。在这里`()`被赋予了新的含义，表明函数的第一个参数是一个`a -> a`类型
的函数。第二个参数是某种类型的值，并返回值也是这种类型。这里我们需要以柯里化函数的思想去阅读
这个问题，并在脑海中理解。就可以简单的理解，这个有两个参数，返回一个值，然后第一个参数是
`a -> a`类型的函数，返回值为`a`类型的值。这个函数可以是`Int -> Int`或`String -> String`或
其它，但第二个参数的类型必须与之前的表示一样。

> 从现在开始，我们说，那些使用多个参数的函数，实际上都是将其分解成使用一个参数的函数，返回
一个部分应用的函数，直到某一个函数返回确定的值。尽管我们知道其在背后的实际情况，但出于简单
的目的，我们还是说`a -> a -> a`使用两个参数，并返回一个`a`类型的值。

函数的函数体十分简单，只是将`f`作为一个函数，传入`x`进行计算一次，计算后的结果再传入`f`。
看下函数调用的几个实例：

```haskell
ghci> applyTwice (+3) 10  
16  
ghci> applyTwice (++ " HAHA") "HEY"  
"HEY HAHA HAHA"  
ghci> applyTwice ("HAHA " ++) "HEY"  
"HAHA HAHA HEY"  
ghci> applyTwice (multThree 2 2) 9  
144  
ghci> applyTwice (3:) [1]  
[3,3,1]  
```

部分应用的魅力和好处是多么得明显！如果我们的函数需要一个函数作为参数，且这个函数也只需要
一个参数，那么我们就可以传递一个部分应用的函数给它。


现在我们将使用更高阶的编程技巧，去实现在标准库一个十分有用的函数。它叫做"zipWith"。它使
用一个函数和两个列表作为参数，然后将两个列表内连(即各个元素按次序依次相对应)，然后在各个
元素对中调用这个函数。现在让我们来实现它：

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]  
zipWith' _ [] _ = []  
zipWith' _ _ [] = []  
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

让我们看下它的函数类型定义。第一参数是一个函数，这个函数使用两个参数返回另一个数，它们的参数
类型不需要都一样，但它们也可以一样。第二个参数和第三个参数都是列表，返回的结果也是列表，第
一个列表中的元素都是`a`类型，作为传入参数的函数第一个参数是`a`，第二个列表中的元素类型都
是`b`类型，因为传入参数的函数的第二个参数是`b`，返回的列表是`c`的列表。如果传入参数的类型
定义为`a -> b ->c`，同样它的类型也包括`a -> a-> a`，但反过来就不适用了。记住，当你在编写
函数时，特别是一些高阶的函数，如果不确定函数的类型，你可以先省略函数的定义，然后使用`:t`
命令进行查看。

这个函数的功能和普通的`zip`功能差不多相似。它们的边界条件是一样的，不同在于`zipWith`多了
一个函数作为参数，但这个函数并不会去影响边界条件，所以我只是使用了`_`来代替它。最后一个模式
匹配和`zip`也最后一个也十分相似，除了它没有在`(x,y)`这样的操作，而是使用了`f x y`。如果
一个高阶函数够通用，那么它可以用于许多比较困难的问题中。下面是一些是我们的`zipWith`函数与
不同的函数/参数搭配的一些结果：

```haskell
ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]  
[6,8,7,9]  
ghci> zipWith' max [6,3,2,1] [7,3,1,5]  
[7,3,2,5]  
ghci> zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]  
["foo fighters","bar hoppers","baz aldrin"]  
ghci> zipWith' (*) (replicate 5 2) [1..]  
[2,4,6,8,10]  
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
[[3,4,6],[9,20,30],[10,12,12]]  
```

如你所见，一个高阶函数可以用于不同的场景下。而通常在命令式语言中是做一些`for`循环、`while`
循环、设置中间变量的形式去实现，然后将这个实现方式进行封装，这就是命令式语言中的函数。函
数式编程使用高阶函数，把具体的模式进行抽象，如果测试两列表的对值、在对值上做一些操作、返
回特定的集合或去除一需要的元素(ps: 更多的是理解问题上的方式，而不于说如何去关心具体的操
作)。

现在来来实现另一个标准库的函数`flip`，它使用一个函数作为参数，并返回像我们原始函数的一个
函数，且将传入的参数位置互换。下面看我们如何去实现：

```haskell
flip' :: (a -> b -> c) -> (b -> a -> c)  
flip' f = g  
    where g x y = f y x  
```

仔细看下这个函数类型定义，我们说这方法是使用`a`和`b`作为参数，返回一个使用`b`和`a`的函数
(ps:重点就在于参数的位置顺序)。由于函数都是柯里化的函数，因为`->`就是表示右连的，所以第二
对括号不是必需的。`(a -> b -> c) -> (b -> a -> c)`和`(a -> b -> c) -> (b -> (a -> c))`
是一样的，也和`(a -> b -> c) -> b -> a -> c`一样。我们有写`g x y = f y x`，如果是`true`，
那么`f y x = g x y`是不是也应该有效。记住这一点，我们可以更简单的组织方式进行定义：

```haskell
flip' :: (a -> b -> c) -> b -> a -> c  
flip' f y x = f x y  
```
