# 高阶函数

> `Haskell`的函数可以使用函数作为参数，并且将函数作为返回值。执行这种操作的函数称为**高
阶函数**。高阶函数并不只有`Haskell`有，其它语言也有，但在`Haskell`中使用高阶函数更加美
妙。其它语言可能需要你定义一步步操作去修改不同变量的值，或者使用循环语句去执行一些操作，
在`Haskell`中，你只需要定义你的原始数据是什么就能帮你完成计算。高阶函数对于任何语言都是
必不可少的，它对于解决问题和思考程序设计是强有力的工具。

## 柯里化函数 [Curried functions](https://zh.wikipedia.org/wiki/%E6%9F%AF%E9%87%8C%E5%8C%96)

在正式定义中，`Haskell`的函数都只使用一个参数的形式。你可能会想，这怎么可能，到目前为止，
我们已经使用过了好多函数都是使用了多个参数的形式。好吧，这是一个很聪明的小技法。目前我们
所使用到的，看似使用多个参数的函数其实都是柯里化函数。那到底是什么意思？我们通过一个案例
去理解。下面请出我们的好朋友：`max`方法。`max`方法好像使用两个参数并返回其中一个较大者。
在执行`max 4 5`的过程中，首先选择一个参数，如`max 4`，返回结果为一个函数，然后再拿`5`作
为其参数，最后返回我们需要的较大者。这个看起来很怪，但确实是一个不错的想法。下面两个调用
方法是等价的。

```haskell
ghci> max 4 5  
5  
ghci> (max 4) 5  
5  
```

使用空格将不同的标识隔开，是比较简单的函数范式。空格符号就你是一个操作符号，并且它具有较
高的优先级。先让我们看下`max`的类型，`max :: (Ord a) => a -> a -> a`，它还可以写成
`max :: (Ord a) => a -> (a -> a)`。可以理解成`max`函数使用一个`a`作为参数，并返回一个
另一个函数，返回的函数使用`a`作为参数，并返回`a`。这就是为什么返回类型和参数之间使用箭头
作为分隔。

那这些对于我们来说，有什么帮助呢？简单来说，如果我们没有太多参数的函数，意味函数执行并没
有过多参数的参与，这一类方法叫做`partially applied 函数`。使用这一类的函数是比较简洁的，
我们将函数传递到其它函数作为参数或者传入数据到这些函数。

给出下面这个例子

```haskell
multThree :: (Num a) => a -> a -> a -> a  
multThree x y z = x * y * z
```
当我们执行`multThree 3 5 9`或`((multThree 3) 5) 9`，会发生什么？首先，因为使用空格分
隔，`3`被应用于函数`multThree`，返回以使用一个参数，且返回值为函数的一个函数。所以`5`接
着被应用于返回的函数中，再一次返回以使用一个参数，且返回值为函数的一个函数，最后与`15`相
乘，返回`135`。记住，上述的函数类型还可以写成`multThree :: (Num a) => a -> (a -> (a -> a))`。
在`->`前的元素是函数要调用的参数，在其后面是返回值。函数的类型说明指出，使用一个`a`作为
参数，返回一个`(Num a) => a -> (a -> a)`类型的函数。再进一步，返回的函数依然是以一个`a`
作为参数，返回一个函数，形如`(Num a) => a -> a`。最后返回的函数，使用一个`a`作为参数，
并返回一个`a`。

```haskell
ghci> let multTwoWithNine = multThree 9  
ghci> multTwoWithNine 2 3  
54  
ghci> let multWithEighteen = multTwoWithNine 2  
ghci> multWithEighteen 10  
180  
```

我们可以很快速地创建一些少量参数的函数，比如我们要创建一个函数，使用一个`a`作为参数，并
与100比较，我们可以这么做：

```haskell
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred x = compare 100 x  
```

如果我们传入`99`进行调用，会返回`GT`。很简单吧，注意，等式两边的`x`是相等的。现在我们来思
考下`compare 100`的返回值是什么。它会返回一个与`100`比较的函数。这不就是我们想要的吗？
可以使用以下代码进行重写：

```haskell
compareWithHundred :: (Num a, Ord a) => a -> Ordering  
compareWithHundred = compare 100  
```

因为`compare 100`返回的是函数，则函数的类型定义是一样的。`compare`的类型是
`(Ord a) => a -> (a -> Ordering)`，当你使用参数`100`，返回类型为`(Num a, Ord a) => a -> Ordering`
的函数。这里需要加上的一个类型约束，其中`100`属于`Num`这个类型类。

> 请确保你已经理解了柯里化函数和部分应用是如何工作的，它们确实都非常重要。

以代码段的形式，中缀形式的函数也可以成为部分应用。只要用括号`()`括起来，并将要使用的参数
跟在后面。这会创建一个使用一个参数的函数，这个参数将用于右边表达式中缺失的部分。请看下面
这个函数：

```haskell
divideByTen :: (Floating a) => a -> a  
divideByTen = (/10)
```

调用`divideByTen 200`就相当于做了`200/20`的计算，也等同于`(/10) 200`。下面这个函数用于
检查给定字符是否属于大写字母：

```haskell
isUpperAlphanum :: Char -> Bool  
isUpperAlphanum = (`elem` ['A'..'Z'])  
```

特别要指出当你使用减号`-`时，会存在歧义。当按段定义函数时，`(-4)`将返回一个使用一个值减去
`4`这样计算的函数，然而，但我们更希望把`(-4)`当做一个负数，所以当你希望实现上述的操作时，
请使用`(subtract 4)`。

那如果我们执行`multThree 3 4`,而不进行`let`的变量绑定，或不将其传入其函数，又会怎样？

```haskell
ghci> multThree 3 4  
<interactive>:1:0:  
    No instance for (Show (t -> t))  
      arising from a use of `print' at <interactive>:1:0-12  
    Possible fix: add an instance declaration for (Show (t -> t))  
    In the expression: print it  
    In a 'do' expression: print it  
```

返回的错误提示我们，这个表达式将会返回一个类型为`a -> a`的函数，但不知道如何将其打印输出。
这个方法不是`Show`类型类的实例，所以找不到比较友好的输出来表示这个函数。在`GHCI`下输入
`1 + 1`，首先它会计算`1 + 1 = 2`，然后调用`show`的函数，将`2`以文本的形式进行输出。
文本形式的`2`是字符中的`"2"`，再将其输出。

## 按序使用高阶函数

通常，函数使用函数作为参数，并返回另一个函数。为了举例说明，创建一个函数，该函数以一个函数
作为参数，并且它将全被调用两次。

```haskell
applyTwice :: (a -> a) -> a -> a  
applyTwice f x = f (f x)  
```

首先，我们看下函数的类型定义，在之前的章节中，我们从来没有使用过括号`()`，因为我们都认为
`->`是一个右连接的符号。在这里`()`被赋予了新的含义，表明函数的第一个参数是一个`a -> a`类型
的函数。第二个参数是某种类型的值，并返回值也是这种类型。这里我们需要以柯里化函数的思想去阅读
这个问题，并在脑海中理解。就可以简单的理解，这个有两个参数，返回一个值，然后第一个参数是
`a -> a`类型的函数，返回值为`a`类型的值。这个函数可以是`Int -> Int`或`String -> String`或
其它，但第二个参数的类型必须与之前的表示一样。

> 从现在开始，我们说，那些使用多个参数的函数，实际上都是将其分解成使用一个参数的函数，返回
一个部分应用的函数，直到某一个函数返回确定的值。尽管我们知道其在背后的实际情况，但出于简单
的目的，我们还是说`a -> a -> a`使用两个参数，并返回一个`a`类型的值。

函数的函数体十分简单，只是将`f`作为一个函数，传入`x`进行计算一次，计算后的结果再传入`f`。
看下函数调用的几个实例：

```haskell
ghci> applyTwice (+3) 10  
16  
ghci> applyTwice (++ " HAHA") "HEY"  
"HEY HAHA HAHA"  
ghci> applyTwice ("HAHA " ++) "HEY"  
"HAHA HAHA HEY"  
ghci> applyTwice (multThree 2 2) 9  
144  
ghci> applyTwice (3:) [1]  
[3,3,1]  
```

部分应用的魅力和好处是多么得明显！如果我们的函数需要一个函数作为参数，且这个函数也只需要
一个参数，那么我们就可以传递一个部分应用的函数给它。


现在我们将使用更高阶的编程技巧，去实现在标准库一个十分有用的函数。它叫做"zipWith"。它使
用一个函数和两个列表作为参数，然后将两个列表内连(即各个元素按次序依次相对应)，然后在各个
元素对中调用这个函数。现在让我们来实现它：

```haskell
zipWith' :: (a -> b -> c) -> [a] -> [b] -> [c]  
zipWith' _ [] _ = []  
zipWith' _ _ [] = []  
zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys
```

让我们看下它的函数类型定义。第一参数是一个函数，这个函数使用两个参数返回另一个数，它们的参数
类型不需要都一样，但它们也可以一样。第二个参数和第三个参数都是列表，返回的结果也是列表，第
一个列表中的元素都是`a`类型，作为传入参数的函数第一个参数是`a`，第二个列表中的元素类型都
是`b`类型，因为传入参数的函数的第二个参数是`b`，返回的列表是`c`的列表。如果传入参数的类型
定义为`a -> b ->c`，同样它的类型也包括`a -> a-> a`，但反过来就不适用了。记住，当你在编写
函数时，特别是一些高阶的函数，如果不确定函数的类型，你可以先省略函数的定义，然后使用`:t`
命令进行查看。

这个函数的功能和普通的`zip`功能差不多相似。它们的边界条件是一样的，不同在于`zipWith`多了
一个函数作为参数，但这个函数并不会去影响边界条件，所以我只是使用了`_`来代替它。最后一个模式
匹配和`zip`也最后一个也十分相似，除了它没有在`(x,y)`这样的操作，而是使用了`f x y`。如果
一个高阶函数够通用，那么它可以用于许多比较困难的问题中。下面是一些是我们的`zipWith`函数与
不同的函数/参数搭配的一些结果：

```haskell
ghci> zipWith' (+) [4,2,5,6] [2,6,2,3]  
[6,8,7,9]  
ghci> zipWith' max [6,3,2,1] [7,3,1,5]  
[7,3,2,5]  
ghci> zipWith' (++) ["foo ", "bar ", "baz "] ["fighters", "hoppers", "aldrin"]  
["foo fighters","bar hoppers","baz aldrin"]  
ghci> zipWith' (*) (replicate 5 2) [1..]  
[2,4,6,8,10]  
ghci> zipWith' (zipWith' (*)) [[1,2,3],[3,5,6],[2,3,4]] [[3,2,2],[3,4,5],[5,4,3]]  
[[3,4,6],[9,20,30],[10,12,12]]  
```

如你所见，一个高阶函数可以用于不同的场景下。而通常在命令式语言中是做一些`for`循环、`while`
循环、设置中间变量的形式去实现，然后将这个实现方式进行封装，这就是命令式语言中的函数。函
数式编程使用高阶函数，把具体的模式进行抽象，如果测试两列表的对值、在对值上做一些操作、返
回特定的集合或去除一需要的元素(ps: 更多的是理解问题上的方式，而不于说如何去关心具体的操
作)。

现在来来实现另一个标准库的函数`flip`，它使用一个函数作为参数，并返回像我们原始函数的一个
函数，且将传入的参数位置互换。下面看我们如何去实现：

```haskell
flip' :: (a -> b -> c) -> (b -> a -> c)  
flip' f = g  
    where g x y = f y x  
```

仔细看下这个函数类型定义，我们说这方法是使用`a`和`b`作为参数，返回一个使用`b`和`a`的函数
(ps:重点就在于参数的位置顺序)。由于函数都是柯里化的函数，因为`->`就是表示右连的，所以第二
对括号不是必需的。`(a -> b -> c) -> (b -> a -> c)`和`(a -> b -> c) -> (b -> (a -> c))`
是一样的，也和`(a -> b -> c) -> b -> a -> c`一样。我们有写`g x y = f y x`，如果是`true`，
那么`f y x = g x y`是不是也应该有效。记住这一点，我们可以更简单的组织方式进行定义：

```haskell
flip' :: (a -> b -> c) -> b -> a -> c  
flip' f y x = f x y  
```

鉴于函数都是柯里化的，当我们不带`x`和`y`调用`filp' f`，时，它会返回一交换两个参数顺序的结果。尽管类似这样的函数经常被当作参数传递给其它函数，通过事先考虑并写下要返回的结果，便可更好地
利用柯里化函数的优势。

```haskell
ghci> flip' zip [1,2,3,4,5] "hello"  
[('h',1),('e',2),('l',3),('l',4),('o',5)]  
ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]  
[5,4,3,2,1]  
```

## Maps和filters

`map`使用一个参数函数和一个列表，列表中的每一个元素都被去调用参数函数，返回一个新的列表。
让我们看下它的声明和定义：

```haskell
map :: (a -> b) -> [a] -> [b]  
map _ [] = []  
map f (x:xs) = f x : map f xs
```

其类型声明表示,这个函数使用一个使用`a`返回`b`的函数作为参数，并使用一个`a`的列表作为参数，
最后返回一个`b`的列表。通过查看函数的类型声明，就十分有趣，你可能就已经知道它具体是做什么
的了。`map`是从多种高阶函数之一，可以用在许多不同的地方：

```haskell
ghci> map (+3) [1,5,3,1,6]  
[4,8,6,4,9]  
ghci> map (++ "!") ["BIFF", "BANG", "POW"]  
["BIFF!","BANG!","POW!"]  
ghci> map (replicate 3) [3..6]  
[[3,3,3],[4,4,4],[5,5,5],[6,6,6]]  
ghci> map (map (^2)) [[1,2],[3,4,5,6],[7,8]]  
[[1,4],[9,16,25,36],[49,64]]  
ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]  
[1,3,6,2,2]  
```

你可以能发现了，上面这些都可以通过列表表达式去实现。`map (+3) [1,5,3,1,6]`和`[x+3 | x <- [1,5,3,1,6]]`
是一样的。然而，当一个函数作为参数时，使用`map`函数更具有可读性。特别你在处理嵌套的`map`时，
那么多的方法括号`[]`看着也很乱。

`filter`函数是一个使用一个断言(断言是一个函数，告诉你什么情况下是`true`或什么时候是`false`)，
和一个列表，用列表中的每一个元素去测试这个断言。它的类型声明和实现如下：

```haskell
filter :: (a -> Bool) -> [a] -> [a]  
filter _ [] = []  
filter p (x:xs)   
    | p x       = x : filter p xs  
    | otherwise = filter p xs  
```

十分简单的例子！如果`p x`执行返回`True`，这个元素将包含在新的列表中，如果不是，则这个元素
将普查排除。一些使用的例子如下：

```haskell
ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]  
[5,6,4]  
ghci> filter (==3) [1,2,3,4,5]  
[3]  
ghci> filter even [1..10]  
[2,4,6,8,10]  
ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]  
[[1,2,3],[3,4,5],[2,2]]  
ghci> filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"  
"uagameasadifeent"  
ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"  
"GAYBALLS"  
```

上面的所有功能都可以使用列表推导式实现。没有任何规定说，什么时候用`filter`实现，什么时候
用列表推导式实现。你只要根据可读性选择使用即可。使用`filter`时和使用列表推导式一样可以使用
逻辑运算符`&&`来连接多个断言。

还记得上一章节中讲的`快速排序`的例子吗？我们使用列表推导式过滤出小于中间值或大于等于中间值
的列表。使用`filter`，代码可读性强，可实现相同的功能。

```haskell
quicksort :: (Ord a) => [a] -> [a]    
quicksort [] = []    
quicksort (x:xs) =     
    let smallerSorted = quicksort (filter (<=x) xs)  
        biggerSorted = quicksort (filter (>x) xs)   
    in  smallerSorted ++ [x] ++ biggerSorted  
```

`map`和`filter`是所有函数式编程语言中必有的东西。使用`map`、`filter`或使用列表推导式都
是没有任何问题的，只要能实现功能就可以。回忆下之前我们是如何在一个中心的周围找到合适的三角
形的。在命令式(过程式)的语言中，我们可以使用三个嵌套的一循环语句然后测试当前的组合是否满足
要找的三角形的条件。如果条件满足，则将其打印。在函数式编程中，这个逻辑就可以使用`mapping`和
`filtering`来实现。你只要创建一个使用一个参数并返回一些结果的函数，这个函数会遍历列表中所有
值，然后通过`filter`过滤出满足我们要求的结果。正是由于`Haskell`中的惰性求值，让我们在多次
在同一个列表中调用`filter`和`map`时，过列表中的元素只需要一次。

现在让我们找一下小于`100000`且能被`3829`整除的最大的数，为了实现这个，我们需要将所有可能的数
检查一次，下面是我们的解决方案：

```haskell
largestDivisible :: (Integral a) => a  
largestDivisible = head (filter p [100000,99999..])  
    where p x = x `mod` 3829 == 0  
```

首先我们要先创建一个按降序排列、小于`100000`所有数的列表，然后去通过我们的声明的断言去
过滤，正因为所有的数都是已经按降序排列的，当最大的那个满足我们断言的那个元素返回`True`时，
后面的元素将不会被执行断言的判定。惰性求值在这里又发挥了重大的作用。因为我们只是需要所满足
数列表中的第一个，不需要去关心列表是有限的还是无穷的。程序会停止，如果第一个满足要求已经被
找到。

下面，我们将要求所有平方小于`10000`,且为奇数的和。但是首先，在这个解决方案中，我们将先介绍
下`takeWhile`函数。这个函数使用一个断言和一个列表作为参数，从列表的第一个参数开始到列表结束
去测试这个断言，一旦有一个元素不符合断言就不再继续执行。如果我们要找出字符串`"elephants know how to party"`
中的每一个单词，可以使用`takeWhile (/=' ') "elephants know how to party`，然后它会返
回`elephants`。好吧。现在说下如何对所有平方为奇数且小于`10000`的数进行求和。首先使用`(^2)`去`map`一个无穷列表`[1..]`，然后过滤出只有奇数的列表，再通过`takeWhile`选择小于`10000`
的值，最后使用`sum`进行求和。我们不需要定义一个函数，在`GHCI`中可以很快实现。

```haskell
ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))  
166650  
```

是不是很神奇。我们使用一些原始数据(自然数的无穷序列)，然后`map`之、`filter`之，再将其截
断取符合我们需要的，再将它们求和。当然我们也可以使用列表推导式：

```haskell
ghci> sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])  
166650  
```

你觉得哪一个简单，那就是你个偏好的问题啦。再强调一次，`Haskell`中的隋性求值让我们能够`map`
和`filter`一个无限列表，这是因为它不会马上就行`map`和`filter`。正由于它的这些执行操作，
只有我们需要`Haskell`返回由`takeWhile`出来列表的和时，`takeWhile`都会去`filter`和`map`
数据，直到有一个数大于等于`10000`就会停止。

好，下一个问题我们来处理这么一个序列。我们使用一个自然数，如果这个自然是偶数就将它除以`2`，
如果这个自然数是奇数就将它乘以`3`再加`1`。相同的逻辑也同样应用于上一个的返回结果中，并产
生一个新的数。事实上，我们得到了一串数值信息。对于所有最初的值，这串值的最后一个值为`1`。
所以当我们使用一个数值`13`，我们会得到序列：`13, 40, 20, 10, 5, 16, 8, 4, 2, 1`。`13*3 + 1`
等于`40`，`40`除以`2`等于`20`，这样一直下去，如此之后，有`10`个这样的操作周期。

现在我们想知道：从`1`到`100`中，有多少个数与上述相同的周期有几个？首先，我们先看看定义这么
一个函数并调用一下：

```haskell
chain :: (Integral a) => a -> [a]  
chain 1 = [1]  
chain n  
    | even n =  n:chain (n `div` 2)  
    | odd n  =  n:chain (n*3 + 1)  
```

最后一个值为`1`，显然就是递归的边界条件。这是一个标准的递归函数。

```haskell
ghci> chain 10  
[10,5,16,8,4,2,1]  
ghci> chain 1  
[1]  
ghci> chain 30  
[30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
```

看起来工作非常正常。现在，下面一个函数将告诉我们上一个问题的答案：

```haskell
numLongChains :: Int  
numLongChains = length (filter isLong (map chain [1..100]))  
    where isLong xs = length xs > 15  
```

我们使用`map`函数对`[1..100]`是每个元素进行`chain`操作，每一次`chain`操作都返回一个列表，
然后过滤出其中长度大于`15`的，执行完一次`filter`后，我们就知道结果列表中有多个长度大于`15`
的列表。

> 注意：在这个函数中使用`numLongChains :: Int`是因为`length`返回的是`Int`类型，而不是
`Num`类型，这当然有它的历史原因。如果你想得到更为普通的数，可以使用`fromIntegral`被应用
于返回的结果上。

我们当然也可以这样使用`map`，`map (*) [0..]`,它可以很好的展示柯里化函数是如何工作的及分部
应用函数确确实实是数值类型(你只是不能将它们转换成字符串)。目前为止，我们所传递给`map`的函数
都只是拿列表中的一个元素作为参数，比如`map (*2) [0..]`,其类型声明可表示为`(Num a) => [a]`。
但是我们也可以使用`map (*) [0..]`，这个完全没有任何问题。那这里又会发生什么呢？原因在于
列表中的一个元素应用于`*`函数，而这个函数的类型是`(Num a) => a -> a -> a`，使用一个类型为
`a`作为参数，返回一个另一个函数，这个函数也是只有一个参数并返回值类型为`a`。如果我们在列表
`[0..]`上`map`使用`*`，则我们将得到一个元素类型为函数的列表，其中的函数都使用一个参数，
返回类型如`(Num a) => [a -> a]`。`map (*) [0..]`返回一个列表，如果写出的话就应该是
`[(0*),(1*),(2*),(3*),(4*),(5*)...`。

```haskell
ghci> let listOfFuns = map (*) [0..]  
ghci> (listOfFuns !! 4) 5  
20  
```

取得下标为`4`的元素，它是一个函数，相当于`(4*)`，然后我们将`5`作为参数传入。执行的过程
就如`(4*) 5`或`4 * 5`。

## Lambdas

`Lambda`表达式是基本的匿名函数，特别在我们只使用函数一次的情况下常常会用到。一般情况下，
我们将创造的`Lambda`表达式传入到一个高阶函数。要编写`Lambda`表达式，你要先写一个`\`，
然后写出它的参数，使用空格分隔，再其后紧跟`->`，再写函数体。通常我们都需要使用括号`()`将
它们括起来。不然，`Lambda`表达式会一直向右延伸开来。

之前我们有在`numLongChains`函数中使用`where`绑定去定义一个`isLong`的函数，这个函数的作为
在于如何去过滤元素。现在我们使用`Lambda`表达式进行重写：

```haskell
numLongChains :: Int  
numLongChains = length (filter (\xs -> length xs > 15) (map chain [1..100]))
```

`Lambda`表达式，人如其名，它就是一个表达式。这就是为什么我们可以将它在这里使用。表达式
`(\xs -> length xs > 15)`返回一个函数，用于测试一个列表的长度是否大于`15`。


一些对柯里化函数和分部应用不怎么熟悉的小伙伴经常会在不需要`Lambda`表达式中的地方使用
`Lambda`表达式。比如`map (+3) [1,6,3,2]`和`map (\x -> x + 3) [1,6,3,2]`是等价的，
`(+3)`和`(\x -> x + 3)`的作用都将一个数加`3`。不得不说，在这个地方使用`Lambda`表达式
是一种`stupid`的方法，因为使用分部应用更具有可读性。

和其它的函数一样，`Lambda`表达式也可以使用多个参数

```haskell
ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]  
[153.0,61.5,31.0,15.75,6.6]  
```

也和其它函数一样，你可以在`Lambda`表达式中使用模式匹配。唯一的不同的地方再于，你不能定义
对单一的一个参数进行模式匹配。
