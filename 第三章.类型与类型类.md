# 类型与类型类


## 信类型，得天下

前一章节，我们提到`Haskell`是静态类型系统，出代码安全的考虑，在编译时，所有表达式的类型
都是已知的。如果你在程序中尝试将一些数值赋给一些`boolean`类型的变量，它将不能通过编译。
这个机制有利于在编译时，捕获程序出错，将检错能力提前。在`Haskell`中，什么都有一个类型，
所以编译前，编译器会对你的程序进行多方面的考查、检错。

不同于`Java`和`Pascal`，`Haskell`有类型推断的特点。即你不告诉`Haskell`其类型是数值，它
也可以通过你的表达式推断出给出函数或表达式的类型。所以在编写过程中，你不需要指定每一个函
数、表达式的类型。这里我们只展示`Haskell`类型机制的冰山一角，但理解类型系统对学习`Haskell`
很重要的一部分。

每一个表达式都有自己表示类型的签名，告诉我们这个表达式如何使用。如`True`是布尔类，
`"hello"`是字符串类型，等等。

现在让我们使用`GHCI`还体验下一些表达式的类型。可以通过`:t`命令，后面跟上有效的表达式，会
返回该表达式的类型。

```haskell
ghci> :t 'a'  
'a' :: Char  
ghci> :t True  
True :: Bool  
ghci> :t "HELLO!"  
"HELLO!" :: [Char]  
ghci> :t (True, 'a')
(True, 'a') :: (Bool, Char)  
ghci> :t 4 == 5  
4 == 5 :: Bool  
```

可以看到，使用`:t`，在其后加入表达式，将输出该表达式，加`::`，再加上其类型，`::`应该被读
作`有类型为`。显式类型通常将类型的第一个字母大写。如`a`是一个`Char`类型，这个是通常的书写
习惯。`True`是`Bool`类型。但这些又是什么?查看`"HELLO"`的类型，返回`[Char]`。方括号表明这
是一个列表，需要被认为是一个包含字符的列表。不同于列表，不同的元组有不同的类型，如
`(True, 'a')`是`(Bool, Char)`，`('a','b','c')`是`(Char, Char, Char)`，而对于`4 == 5`
总是返回`False`，所以是一个`Bool`类型。

函数也有类型，在编写函数时，我们可以显示的指定函数的函数类型。这是一种良好的代码编写习惯，
当然，当你编写较短的函数时，可以不这样写。从这里开始，所有我们所运用到的函数，我们给出函数
的类型定义。前面我们使用列表推导式用于过滤，只留下是大写字符的元素。下面是它的类型定义。

```haskell
removeNonUppercase :: [Char] -> [Char]  
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

`removeNonUppercase`是`[Char]->[Char]`类型,说明它对应着字符串到字符串的函数，使用一个
字符串作为参数，并返回一个字符串。`[Char]`类型等同于`String`。所以我们如果编写说明时使用
`removeNonUppercase :: String -> String`将更加清楚。然而我们不需要这么做，因为编译器
会帮助我们推测并判定这个函数是由`字符串->字符串`的。那我们如何编写需要多个参数的函数定义
呢？下面是一个简单的示例，进行三个数相加的运算：

```haskell
addThree :: Int -> Int -> Int -> Int  
addThree x y z = x + y + z  
```

参数之间使用`->`分隔，在参数和返回值的处理上，没有任何区别。在该定义中，最后一项是返回值，
前面三个为参数。下面的内容中，我们会知道为什么仅使用`->`分隔的定义能代替形如`Int, Int, Int -> Int`
(这种定义，参数与返回就有明显的区别)的定义。

当你不确定如何给你编写的函数指出明确的类型定义，你可以直接将函数写出来，并使用`:t`命令去查。
请坚信，**函数也是一种表达式**，使用`:t`去查看其类型，是没有任何问题的。

先看下一些比较通用的类型。

`Int`表示整数类型，可以用于大部分的数字，`7`可以是`Int`类型，但`7.2`就不是`Int`类型。
`Int`类型是有边界值的类型，有能表示的最大值和最小值。通常在32位操作系统中，能表示的最大
值为2147483647，最小值为-2147483648

`Integer`，不好意思，还是表示整数类型，但它是没有边界概念，你可以使用它来表示更大的值。
往往`Int`更有效。

```haskell
factorial :: Integer -> Integer  
factorial n = product [1..n]
```

```haskell
ghci> factorial 50  
30414093201713378043612608166064768844377641568960512000000000000
```

`Float`表示有单精度的浮点数类型。

```haskell
circumference :: Float -> Float  
circumference r = 2 * pi * r
```

```haskell
ghci> circumference 4.0  
25.132742  
```

`Double`表示双精度的浮点数类型。

```haskell
circumference' :: Double -> Double  
circumference' r = 2 * pi * r  
```

```haskell
ghci> circumference' 4.0  
25.132741228718345
```

`Bool`是布尔类型，只有两个值:`True`和`False`。

`Char`表示字符类型，用于表示单个字符，一组字符中的列表表示一个字符串。

元组也是一种类型，但它具体的类型是根据在元组中所包含的元素的类型。所以在理论上，元组有无数
种类型，本教程不可能所有都涉及到。注意，空的元组`()`也有类型，用于表示空的元组。

## 类型变量

现在来思考`head`函数是什么类型，该函数使用一组列表作为参数并返回列表中的第一个元素，会是什么
类型呢？让我们来检验下：

```haskell
ghci> :t head  
head :: [a] -> a
```

我去!这个`a`是什么类型？注意到我们先前所涉及到类型都是大写开头，所以它是泛指某一类类型，
而不精确地指定某种特定类型。因为不是使用大写开头，它其实是一种类型变量，它可以表示出任何
类型。在其它语言中也十分常见，但只有在`Haskell`中显得更为强大，因为你可以定义任何不需要
指定明确类型的参数的函数。如果一个函数有类型变量作为参数，则这个函数可以称为`多态函数`。从
`head`的函数类型定义中可以看出，使用一组包含某种类型的列表作为参数，并返回该种类型的第一
个元素。

尽管类型参数变量的标识不限定要多少个字符，但通常都是以`a,b,c,d`来标识。

看下`fst`函数，它返回一对值中的第一个值，下面来测试一下：

```haskell
ghci> :t fst  
fst :: (a, b) -> a
```

我们看到`fst`函数使用一个元组，其中包含两个元素，且这两个元素的类型是一样的作为参数，返回
第一个元素。看函数的类型定义，其中`a`和`b`分别表示不同的类型参数变量，所以使用`fst`你可以
将包含两个不同类型的元素的元组作为参数。元组中的第一个元素的类型和返回值的类型是一样的。

## 类型类 101 (直接说明是接口，会不会更好理解……)

类型类是一组具有相同行为的接口，如果说一种类型是一个类型类的一部分，那么说可以去扩展并实现
由类型类中所定义的行为。有`OOP`面向对象开发经验会觉得类型类和那些面向对象语言中的类一样。
那你们就错了，不过你们可以理解类型类就像是`Java`语言中的接口。

那你觉得`==`是什么函数？

```haskell
ghci> :t (==)  
(==) :: (Eq a) => a -> a -> Bool
```
> 注意相等`==`是一个函数，`+,*,-,/`也是一样的。如果一个函数是由特殊字符组成，默认以中缀
表达式形式调用。如果将其传入其它函数作为参数，或者以前缀形式调用，则需要用括号括起来。

有趣的事，这里我们看到一个新的符号`=>`。在`=>`前的符号统称约束类(规定参数的类型)，上述的
函数类型定义可以理解为：相等函数使用两个相同类型的参数，并返回一个`Bool`类型。作为参数的
两个值的类型必须是`Eq`类型类。

`Eq`类型提供了一个用于测试相等的接口。任何类型的值如果想进行判断是否相等的操作则必须也要
属于`Eq`类型类。`Haskell`中所有的标准内置的类型，除了`IO`(用于处理输入、输出)和函数,都
是属于`Eq`类型类。

`elem`函数，其类型为`(Eq a) => a -> [a] -> Bool`。注意，为什么需要`Eq`。因为在检查相
等的过程中，会使用到`==`逐一进行比较。

给出几个基本的类型类：

`Eq`，用于测试相等操作。属于`Eq`类型类的成员都实现了`==`和`/=`函数。正因如此，在函数类型
定义中有一个类约束，用于标识其值可以执行`==`和`/=`操作。上面所有我们提及到的类型，除了函
数都是属于`Eq`类型类，都可以测试相等。


`Ord`可以用于排序。

```haskell
ghci> :t (>)  
(>) :: (Ord a) => a -> a -> Bool
```

有所提到的所有类型，除了函数，都`Ord`类型类。`Ord`包含了所有标准的比较函数，如`>`，`<`，
`>=`和`<=`。`compare`函数使用两个属于`Ord`类型类的值，返回一个排序。`Ordering`包含`GT`、
`LT`，`EQ`，分别表示大于、小于、等于。

要成为`Ord`中的一员，那它必要也要属于`Eq`类型类。

```haskell
ghci> "Abrakadabra" < "Zebra"  
True  
ghci> "Abrakadabra" `compare` "Zebra"  
LT  
ghci> 5 >= 2  
True  
ghci> 5 `compare` 3  
GT  
```

属于`Show`类型类的值，可以以字符串的形式输出。所涉及到的，除了函数的值都属于`Show`类型
类。最为常用的方法就是`show`，使用一个属于`Show`类型类的值，并将其以字符串输出。

```haskell
ghci> show 3  
"3"  
ghci> show 5.334  
"5.334"  
ghci> show True  
"True"  
```

`Read`则正好与`Show`相反。使用一个字符串的值，并返回一个属于`Read`的成员。

```haskell
ghci> read "True" || False  
True  
ghci> read "8.2" + 3.8  
12.0  
ghci> read "5" - 2  
3  
ghci> read "[1,2,3,4]" ++ [3]  
[1,2,3,4,3]  
```

太棒了!（@ _ @棒在哪里!!!）`Bool、浮点、整数、列表`都属于这个类型类。但如果仅仅执行`read "4"`，
又会发生什么？

```haskell
ghci> read "4"  
<interactive>:1:0:  
    Ambiguous type variable `a' in the constraint:  
      `Read a' arising from a use of `read' at <interactive>:1:0-7  
    Probable fix: add a type signature that fixes these type variable(s)
```

`GHCI`返回显示，它不知道我们希望返回的是什么类型。上面我们使用`read`时，都将结果与其它
直接进行处理。正是如此，`GHCI`能推断出我们想要的类型。如果我们像`Bool`类型一样使用，则返
回`Bool`类型。但现在，`GHCI`只知道我们想要返回一个属于`Read`类型类的值，但不知道具体是
哪一个。让我们再看一下`read`的函数类型定义。

```haskell
ghci> :t read  
read :: (Read a) => String -> a  
```

看明白了，它返回的属于`Read`类型类的值，目前我们还不打算使用这种类型类，因为没有办法知道
具体属于哪种类型类。这就是什么使用显式的类型说明。类型说明可以指明一个表达式中的值是属于
什么类型。在表达式返回加上`::`标明类型，如下：

```haskell
ghci> read "5" :: Int  
5  
ghci> read "5" :: Float  
5.0  
ghci> (read "5" :: Float) * 4  
20.0  
ghci> read "[1,2,3,4]" :: [Int]  
[1,2,3,4]  
ghci> read "(3, 'a')" :: (Int, Char)  
(3, 'a')  
```

绝大多数的表达式可以这么做，这么编译器可以推断出它的具体类型。但有时，编译器也无法知道，比
如`read "5"`，到底是返回`Int`还是`Float`。到底属于哪种类型，`Haskell`会对其进行推测。但
因为`Haskell`是静态类型语言，在编译后，需要知道所有值的类型，所以我们在编写时，告诉编译器
是什么类型，万一它不知道怎么办。

`Enum`类型类的值是线性、有序的类型，可以被枚举，最大的好处再于可以使用列表区间进行使用。
使用`succ`和`pred`可以返回一个值的前驱和后继。下面类型都属于这个类型类：

```haskell
(), Bool, Char, Ordering, Int, Integer, Float, Double
```

```haskell
ghci> ['a'..'e']  
"abcde"  
ghci> [LT .. GT]  
[LT,EQ,GT]  
ghci> [3 .. 5]  
[3,4,5]  
ghci> succ 'B'  
'C'  
```

`Bounded`类型类表示其有上界和下界。

```haskell
ghci> minBound :: Int  
-2147483648  
ghci> maxBound :: Char  
'\1114111'  
ghci> maxBound :: Bool  
True  
ghci> minBound :: Bool  
False  
```

`minBound`,`maxBound`这两个函数十分有趣，可以从它们的类型定义中看出，`(Bounded a) => a`，
一看就知道是多态的函数。

如果元组中的元素是`Bounded`类型类的，则所有的元组都是`Bounded`类型类的。

```haskell
ghci> maxBound :: (Bool, Int, Char)  
(True,2147483647,'\1114111')  
```

`Num`是数值类型类，定义了数值类型的属性。测试一下先，

```haskell
ghci> :t 20  
20 :: (Num t) => t
```

上述定义，看出是一个多态的约束


```haskell
ghci> 20 :: Int  
20  
ghci> 20 :: Integer  
20  
ghci> 20 :: Float  
20.0  
ghci> 20 :: Double  
20.0  
```

这些类型是属于`Num`类型类的。如果检测下`*`的类型，也可以看到它接受所有的数字。

```haskell
ghci> :t (*)  
(*) :: (Num a) => a -> a -> a
```

使用两个相同类型的值进行操作，这也是为什么执行`(5 :: Int) * (6 :: Integer)`会报错。又
如`5 * (6 :: Integer)`就可以正常工作，因为`5`可以被认为是`Integer`或者`Int`。

如果一个类型属于`Num`类型类，则它也一定属于`Show`和`Eq`类型类。

`Integral`也是一个数字的类型类。`Num`包含了所有的数字，如实数、整数。`Integral`仅仅包含
整数。属于这个类型类的类型有`Int`和`Integer`。

`Floating`仅包含浮点数值，有`Float`和`Double`类型。

`fromIntegral`处理数值，十分有用。它的类型定义如：`fromIntegral :: (Num b, Integral a) => a -> b`，
从类型定义中看出，使用一个整数，将其转换为更为通用的数值。当你同时操作整数和浮点数时，这
非常有用。比如，`length`方法，其类型定义为`length :: [a] -> Int`，而不是有更通用类型的
`(Num b) => length :: [a] -> b`。我想这里应该有什么历史原因吧，但在我想法里，这真是一个
不好的地方。不管怎样，如果想得到一个列表的长度，再加上`3.2`，在不使用`fromIntegral`会报错。
那就使用`fromIntegral (length [1,2,3,4]) + 3.2`，会正确返回。

注意：`fromIntegral`的类型定义中有多个类型约束，这样是合法的，书写方式就是在括号中，使用
逗号进行分隔。
