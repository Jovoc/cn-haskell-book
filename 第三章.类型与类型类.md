# 类型与类型类


## 信类型，得天下

前一章节，我们提到`Haskell`是静态类型系统，出代码安全的考虑，在编译时，所有表达式的类型
都是已知的。如果你在程序中尝试将一些数值赋给一些`boolean`类型的变量，它将不能通过编译。
这个机制有利于在编译时，捕获程序出错，将检错能力提前。在`Haskell`中，什么都有一个类型，
所以编译前，编译器会对你的程序进行多方面的考查、检错。

不同于`Java`和`Pascal`，`Haskell`有类型推断的特点。即你不告诉`Haskell`其类型是数值，它
也可以通过你的表达式推断出给出函数或表达式的类型。所以在编写过程中，你不需要指定每一个函
数、表达式的类型。这里我们只展示`Haskell`类型机制的冰山一角，但理解类型系统对学习`Haskell`
很重要的一部分。

每一个表达式都有自己表示类型的签名，告诉我们这个表达式如何使用。如`True`是布尔类，
`"hello"`是字符串类型，等等。

现在让我们使用`GHCI`还体验下一些表达式的类型。可以通过`:t`命令，后面跟上有效的表达式，会
返回该表达式的类型。

```haskell
ghci> :t 'a'  
'a' :: Char  
ghci> :t True  
True :: Bool  
ghci> :t "HELLO!"  
"HELLO!" :: [Char]  
ghci> :t (True, 'a')
(True, 'a') :: (Bool, Char)  
ghci> :t 4 == 5  
4 == 5 :: Bool  
```

可以看到，使用`:t`，在其后加入表达式，将输出该表达式，加`::`，再加上其类型，`::`应该被读
作`有类型为`。显式类型通常将类型的第一个字母大写。如`a`是一个`Char`类型，这个是通常的书写
习惯。`True`是`Bool`类型。但这些又是什么?查看`"HELLO"`的类型，返回`[Char]`。方括号表明这
是一个列表，需要被认为是一个包含字符的列表。不同于列表，不同的元组有不同的类型，如
`(True, 'a')`是`(Bool, Char)`，`('a','b','c')`是`(Char, Char, Char)`，而对于`4 == 5`
总是返回`False`，所以是一个`Bool`类型。

函数也有类型，在编写函数时，我们可以显示的指定函数的函数类型。这是一种良好的代码编写习惯，
当然，当你编写较短的函数时，可以不这样写。从这里开始，所有我们所运用到的函数，我们给出函数
的类型定义。前面我们使用列表推导式用于过滤，只留下是大写字符的元素。下面是它的类型定义。

```haskell
removeNonUppercase :: [Char] -> [Char]  
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']]
```

`removeNonUppercase`是`[Char]->[Char]`类型,说明它对应着字符串到字符串的函数，使用一个
字符串作为参数，并返回一个字符串。`[Char]`类型等同于`String`。所以我们如果编写说明时使用
`removeNonUppercase :: String -> String`将更加清楚。然而我们不需要这么做，因为编译器
会帮助我们推测并判定这个函数是由`字符串->字符串`的。那我们如何编写需要多个参数的函数定义
呢？下面是一个简单的示例，进行三个数相加的运算：

```haskell
addThree :: Int -> Int -> Int -> Int  
addThree x y z = x + y + z  
```

参数之间使用`->`分隔，在参数和返回值的处理上，没有任何区别。在该定义中，最后一项是返回值，
前面三个为参数。下面的内容中，我们会知道为什么仅使用`->`分隔的定义能代替形如`Int, Int, Int -> Int`
(这种定义，参数与返回就有明显的区别)的定义。

当你不确定如何给你编写的函数指出明确的类型定义，你可以直接将函数写出来，并使用`:t`命令去查。
请坚信，**函数也是一种表达式**，使用`:t`去查看其类型，是没有任何问题的。

先看下一些比较通用的类型。

`Int`表示整数类型，可以用于大部分的数字，`7`可以是`Int`类型，但`7.2`就不是`Int`类型。
`Int`类型是有边界值的类型，有能表示的最大值和最小值。通常在32位操作系统中，能表示的最大
值为2147483647，最小值为-2147483648

`Integer`，不好意思，还是表示整数类型，但它是没有边界概念，你可以使用它来表示更大的值。
往往`Int`更有效。

```haskell
factorial :: Integer -> Integer  
factorial n = product [1..n]
```

```haskell
ghci> factorial 50  
30414093201713378043612608166064768844377641568960512000000000000
```

`Float`表示有单精度的浮点数类型。

```haskell
circumference :: Float -> Float  
circumference r = 2 * pi * r
```

```haskell
ghci> circumference 4.0  
25.132742  
```

`Double`表示双精度的浮点数类型。

```haskell
circumference' :: Double -> Double  
circumference' r = 2 * pi * r  
```

```haskell
ghci> circumference' 4.0  
25.132741228718345
```

`Bool`是布尔类型，只有两个值:`True`和`False`。

`Char`表示字符类型，用于表示单个字符，一组字符中的列表表示一个字符串。

元组也是一种类型，但它具体的类型是根据在元组中所包含的元素的类型。所以在理论上，元组有无数
种类型，本教程不可能所有都涉及到。注意，空的元组`()`也有类型，用于表示空的元组。

## 类型变量

现在来思考`head`函数是什么类型，该函数使用一组列表作为参数并返回列表中的第一个元素，会是什么
类型呢？让我们来检验下：

```haskell
ghci> :t head  
head :: [a] -> a
```

我去!这个`a`是什么类型？注意到我们先前所涉及到类型都是大写开头，所以它是泛指某一类类型，
而不精确地指定某种特定类型。因为不是使用大写开头，它其实是一种类型变量，它可以表示出任何
类型。在其它语言中也十分常见，但只有在`Haskell`中显得更为强大，因为你可以定义任何不需要
指定明确类型的参数的函数。如果一个函数有类型变量作为参数，则这个函数可以称为`多态函数`。从
`head`的函数类型定义中可以看出，使用一组包含某种类型的列表作为参数，并返回该种类型的第一
个元素。

尽管类型参数变量的标识不限定要多少个字符，但通常都是以`a,b,c,d`来标识。

看下`fst`函数，它返回一对值中的第一个值，下面来测试一下：

```haskell
ghci> :t fst  
fst :: (a, b) -> a
```

我们看到`fst`函数使用一个元组，其中包含两个元素，且这两个元素的类型是一样的作为参数，返回
第一个元素。看函数的类型定义，其中`a`和`b`分别表示不同的类型参数变量，所以使用`fst`你可以
将包含两个不同类型的元素的元组作为参数。元组中的第一个元素的类型和返回值的类型是一样的。

## 类型类 101 (直接说明是接口，会不会更好理解……)

类型类是一组具有相同行为的接口，如果说一种类型是一个类型类的一部分，那么说可以去扩展并实现
由类型类中所定义的行为。
